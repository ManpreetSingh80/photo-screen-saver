<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"alarm.js.html":{"id":"alarm.js.html","title":"Source: alarm.js","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Source: alarm.js /* * Copyright (c) 2015-2017, Michael A. Updike All rights reserved. * Licensed under the BSD-3-Clause * https://opensource.org/licenses/BSD-3-Clause * https://github.com/opus1269/photo-screen-saver/blob/master/LICENSE.md */ window.app = window.app || {}; app.Alarm = (function() { 'use strict'; /** * Manage alarms from the chrome.alarms API * @see https://developer.chrome.com/apps/alarms * @namespace app.Alarm */ const chromep = new ChromePromise(); /** * Alarms triggered by chrome.alarms * @typedef {Object} Alarms * @property {string} ACTIVATE - screen saver is active * @property {string} DEACTIVATE - screen saver is not activate * @property {string} UPDATE_PHOTOS - photo sources should be updated * @property {string} BADGE_TEXT - icon's Badge text should be set * @const * @private * @memberOf app.Alarm */ const _ALARMS = { 'ACTIVATE': 'ACTIVATE', 'DEACTIVATE': 'DEACTIVATE', 'UPDATE_PHOTOS': 'UPDATE_PHOTOS', 'BADGE_TEXT': 'BADGE_TEXT', }; /** * Time constants * @typedef {Object} Time * @property {int} MIN_IN_DAY - minutes in a day * @property {int} MSEC_IN_DAY - milliSeconds in a day * @const * @private * @memberOf app.Alarm */ const _TIME = { 'MIN_IN_DAY': 60 * 24, 'MSEC_IN_DAY': 60 * 60 * 24 * 1000, }; /** * Convert string to time * @param {string} value - format: 'hh:mm' 24 hour time * @returns {int} time in mSec from epoch * @private * @memberOf app.Alarm */ function _getTime(value) { const date = new Date(); date.setHours(parseInt(value.substr(0, 2))); date.setMinutes(parseInt(value.substr(3, 2))); date.setSeconds(0); date.setMilliseconds(0); return date.getTime(); } /** * Calculate time delta from now on a 24 hr basis * @param {string} value - format: 'hh:mm' 24 hour time * @returns {int} time delta in minutes * @private * @memberOf app.Alarm */ function _getTimeDelta(value) { const curTime = Date.now(); const time = _getTime(value); let delayMin = (time - curTime) / 1000 / 60; if (delayMin &lt; 0) { delayMin = _TIME.MIN_IN_DAY + delayMin; } return delayMin; } /** * Determine if current time is between start and stop, inclusive * @param {string} start - format: 'hh:mm' 24 hour time * @param {string} stop - format: 'hh:mm' 24 hour time * @returns {boolean} true if in the given range * @private * @memberOf app.Alarm */ function _isInRange(start, stop) { const curTime = Date.now(); const startTime = _getTime(start); const stopTime = _getTime(stop); let ret = false; if (start === stop) { ret = true; } else if (stopTime &gt; startTime) { if ((curTime &gt;= startTime) &amp;&amp; (curTime &lt;= stopTime)) { ret = true; } } else { if ((curTime &gt;= startTime) || (curTime &lt;= stopTime)) { ret = true; } } return ret; } /** * Set state when the screensaver is in the active time range * @private * @memberOf app.Alarm */ function _setActiveState() { if (app.Storage.getBool('keepAwake')) { chrome.power.requestKeepAwake('display'); } const interval = app.Utils.getIdleSeconds(); chromep.idle.queryState(interval).then((state) =&gt; { // display screensaver if the idle time criteria is met if (state === 'idle') { app.SSControl.display(false); } }).catch((err) =&gt; {}); app.Alarm.updateBadgeText(); } /** * Set state when the screensaver is in the inactive time range * @private * @memberOf app.Alarm */ function _setInactiveState() { if (app.Storage.getBool('allowSuspend')) { chrome.power.releaseKeepAwake(); } else { chrome.power.requestKeepAwake('system'); } app.SSControl.close(); app.Alarm.updateBadgeText(); } /** * Set the Badge text on the icon * @private * @memberOf app.Alarm */ function _setBadgeText() { let text = ''; if (app.Storage.getBool('enabled')) { text = app.Alarm.isActive() ? '' : app.Utils.localize('sleep_abbrev'); } else { text = app.Storage.getBool('keepAwake') ? app.Utils.localize('power_abbrev') : app.Utils.localize('off_abbrev'); } chrome.browserAction.setBadgeText({text: text}); } /** * Event: Fired when an alarm has elapsed. * @see https://developer.chrome.com/apps/alarms#event-onAlarm * @param {Object} alarm - details on alarm * @private * @memberOf app.Alarm */ function _onAlarm(alarm) { switch (alarm.name) { case _ALARMS.ACTIVATE: // entering active time range of keep awake _setActiveState(); break; case _ALARMS.DEACTIVATE: // leaving active time range of keep awake _setInactiveState(); break; case _ALARMS.UPDATE_PHOTOS: // get the latest for the live photo streams app.PhotoSource.processDaily(); break; case _ALARMS.BADGE_TEXT: // set the icons text _setBadgeText(); break; default: break; } } // Listen for alarms chrome.alarms.onAlarm.addListener(_onAlarm); return { /** * Set the repeating alarms states * @memberOf app.Alarm */ updateRepeatingAlarms: function() { const keepAwake = app.Storage.getBool('keepAwake'); const aStart = app.Storage.getBool('activeStart'); const aStop = app.Storage.getBool('activeStop'); // create keep awake active period scheduling alarms if (keepAwake &amp;&amp; (aStart !== aStop)) { const startDelayMin = _getTimeDelta(aStart); const stopDelayMin = _getTimeDelta(aStop); chrome.alarms.create(_ALARMS.ACTIVATE, { delayInMinutes: startDelayMin, periodInMinutes: _TIME.MIN_IN_DAY, }); chrome.alarms.create(_ALARMS.DEACTIVATE, { delayInMinutes: stopDelayMin, periodInMinutes: _TIME.MIN_IN_DAY, }); // if we are currently outside of the active range // then set inactive state if (!_isInRange(aStart, aStop)) { _setInactiveState(); } } else { chrome.alarms.clear(_ALARMS.ACTIVATE); chrome.alarms.clear(_ALARMS.DEACTIVATE); } // Add daily alarm to update photo sources that request this chromep.alarms.get(_ALARMS.UPDATE_PHOTOS).then((alarm) =&gt; { if (!alarm) { chrome.alarms.create(_ALARMS.UPDATE_PHOTOS, { when: Date.now() + _TIME.MSEC_IN_DAY, periodInMinutes: _TIME.MIN_IN_DAY, }); } }).catch((err) =&gt; {}); }, /** * Set the icon badge text * @memberOf app.Alarm */ updateBadgeText: function() { // delay setting a little to make sure range check is good chrome.alarms.create(_ALARMS.BADGE_TEXT, { when: Date.now() + 250, }); }, /** * Determine if the screen saver can be displayed * @returns {boolean} true if can display * @memberOf app.Alarm */ isActive: function() { const enabled = app.Storage.getBool('enabled'); const keepAwake = app.Storage.getBool('keepAwake'); const aStart = app.Storage.get('activeStart'); const aStop = app.Storage.get('activeStop'); // do not display if screen saver is not enabled or // keepAwake scheduler is enabled and is in the inactive range return !(!enabled || (keepAwake &amp;&amp; !_isInRange(aStart, aStop))); }, }; })(); Ã— Search results Close "},"background.js.html":{"id":"background.js.html","title":"Source: background.js","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Source: background.js /* * Copyright (c) 2015-2017, Michael A. Updike All rights reserved. * Licensed under the BSD-3-Clause * https://opensource.org/licenses/BSD-3-Clause * https://github.com/opus1269/photo-screen-saver/blob/master/LICENSE.md */ (function() { 'use strict'; /** * The background script for the extension.&lt;br&gt; * @namespace app.Background */ const chromep = new ChromePromise(); /** * Display the options tab * @private * @memberOf app.Background */ function _showOptionsTab() { // send message to the option tab to focus it. chromep.runtime.sendMessage({ message: 'highlight', }).catch(() =&gt; { // no one listening, create it chrome.tabs.create({url: '../html/options.html'}); }); } /** * Toggle enabled state of the screen saver * @private * @memberOf app.Background */ function _toggleEnabled() { app.Storage.set('enabled', !app.Storage.getBool('enabled')); // storage changed event not fired on same page as the change app.Data.processState('enabled'); } /** * Event: Fired when the extension is first installed,&lt;br /&gt; * when the extension is updated to a new version,&lt;br /&gt; * and when Chrome is updated to a new version. * @see https://developer.chrome.com/extensions/runtime#event-onInstalled * @param {Object} details - type of event * @private * @memberOf app.Background */ function _onInstalled(details) { // create menus on the right click menu of the extension icon chromep.contextMenus.create({ type: 'normal', id: 'ENABLE_MENU', title: app.Utils.localize('disable'), contexts: ['browser_action'], }).catch((err) =&gt; {}); chromep.contextMenus.create({ type: 'separator', id: 'SEP_MENU', contexts: ['browser_action'], }).catch((err) =&gt; {}); if (details.reason === 'install') { app.Data.initialize(); _showOptionsTab(); } else if (details.reason === 'update') { // extension updated app.Data.update(); } } /** * Event: Fired when a profile that has this extension installed first * starts up * @see https://developer.chrome.com/extensions/runtime#event-onStartup * @private * @memberOf app.Background */ function _onStartup() { app.Data.processState(); } /** * Event: Fired when a browser action icon is clicked. * @see https://goo.gl/abVwKu * @private * @memberOf app.Background */ function _onIconClicked() { _showOptionsTab(); } /** * Event: Fired when item in localStorage changes * @see https://developer.mozilla.org/en-US/docs/Web/Events/storage * @param {Event} event - StorageEvent * @param {string} event.key - storage item that changed * @private * @memberOf app.Background */ function _onStorageChanged(event) { app.Data.processState(event.key); } /** * Event: Fired when a context menu item is clicked. * @see https://developer.chrome.com/extensions/contextMenus#event-onClicked * @param {Object} info - info. on the clicked menu * @param {Object} info.menuItemId - menu name * @private * @memberOf app.Background */ function _onMenuClicked(info) { if (info.menuItemId === 'ENABLE_MENU') { _toggleEnabled(); } } /** * Event: Fired when a registered command is activated using * a keyboard shortcut. * @see https://developer.chrome.com/extensions/commands#event-onCommand * @param {string} cmd - keyboard command * @private * @memberOf app.Background */ function _onKeyCommand(cmd) { if (cmd === 'toggle-enabled') { _toggleEnabled(); } } // noinspection JSUnusedLocalSymbols /** * Event: Fired when a message is sent from either an extension process&lt;br&gt; * (by runtime.sendMessage) or a content script (by tabs.sendMessage). * @see https://developer.chrome.com/extensions/runtime#event-onMessage * @param {Object} request - details for the message * @param {string} request.message - name of the message * @param {Object} sender - MessageSender object * @param {function} response - function _to call once after processing * @returns {boolean} true if asynchronous * @private * @memberOf app.Background */ function _onChromeMessage(request, sender, response) { if (request.message === 'restoreDefaults') { app.Data.restoreDefaults(); } return true; } // listen for extension install or update chrome.runtime.onInstalled.addListener(_onInstalled); // listen for Chrome starting chrome.runtime.onStartup.addListener(_onStartup); // listen for click on the icon chrome.browserAction.onClicked.addListener(_onIconClicked); // listen for changes to the stored data addEventListener('storage', _onStorageChanged, false); // listen for chrome messages chrome.runtime.onMessage.addListener(_onChromeMessage); // listen for clicks on context menus chrome.contextMenus.onClicked.addListener(_onMenuClicked); // listen for special keyboard commands chrome.commands.onCommand.addListener(_onKeyCommand); })(); Ã— Search results Close "},"chromecast.js.html":{"id":"chromecast.js.html","title":"Source: chromecast.js","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Source: chromecast.js /* * Copyright (c) 2015-2017, Michael A. Updike All rights reserved. * Licensed under the BSD-3-Clause * https://opensource.org/licenses/BSD-3-Clause * https://github.com/opus1269/photo-screen-saver/blob/master/LICENSE.md */ window.app = window.app || {}; app.ChromeCast = (function() { 'use strict'; /** * Interface to the Chromecast photos * @namespace app.ChromeCast */ return { /** * Get the photos from chromecast.json * @returns {Promise&lt;Photo[]&gt;} Array of {@link Photo} objects * @memberOf app.ChromeCast */ loadImages: function() { const url = '/assets/chromecast.json'; return app.Http.doGet(url).then((photos) =&gt; { for (let i = 0; i &lt; photos.length; i++) { photos[i].asp = 16 / 9; } return Promise.resolve(photos); }); }, }; })(); Ã— Search results Close "},"data.js.html":{"id":"data.js.html","title":"Source: data.js","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Source: data.js /* * Copyright (c) 2015-2017, Michael A. Updike All rights reserved. * Licensed under the BSD-3-Clause * https://opensource.org/licenses/BSD-3-Clause * https://github.com/opus1269/photo-screen-saver/blob/master/LICENSE.md */ window.app = window.app || {}; app.Data = (function() { 'use strict'; /** * Manage the extensions data * @namespace app.Data */ const chromep = new ChromePromise(); /** * Version of localStorage - update when items are added, removed, changed * @type {int} * @default * @const * @private * @memberOf app.Data */ const _DATA_VERSION = 10; /** * A number and associated units * @typedef {Object} UnitValue * @property {number} base - value in base unit * @property {number} display - value in display unit * @property {int} unit - display unit */ /** * Values for items in localStorage * @typedef {Object} AppData * @property {int} version - version of data * @property {boolean} enabled - is screensaver enabled * @property {UnitValue} idleTime - idle time to display screensaver * @property {UnitValue} transitionTime - time between photos * @property {boolean} skip - ignore extreme aspect ratio photos * @property {boolean} shuffle - randomize photo order * @property {int} photoSizing - photo display type * @property {int} photoTransition - transition animation * @property {int} showTime - time display format * @property {boolean} showPhotog - display name on own photos * @property {string} background - background image * @property {boolean} keepAwake - manage computer poser settings * @property {boolean} chromeFullscreen - don't display over fullscreen * Chrome windows * @property {boolean} allDisplays - show on all displays * @property {string} activeStart - Keep Wake start time '00:00' 24 hr * @property {string} activeStop - Keep Wake stop time '00:00' 24 hr * @property {boolean} allowSuspend - let computer sleep * @property {boolean} useSpaceReddit - use this photo source * @property {boolean} useEarthReddit - use this photo source * @property {boolean} useAnimalReddit - use this photo source * @property {boolean} useEditors500px - use this photo source * @property {boolean} usePopular500px - use this photo source * @property {boolean} useYesterday500px - use this photo source * @property {boolean} useInterestingFlickr - use this photo source * @property {boolean} useChromecast - use this photo source * @property {boolean} useAuthors - use this photo source * @property {boolean} useGoogle - use this photo source * @property {boolean} useSpaceReddit - use this photo source * @property {Array} albumSelections - Users Google Photos to use */ /** * Default values in localStorage * @type {AppData} * @const * @private * @memberOf app.Data */ const _DEF_VALUES = { 'version': _DATA_VERSION, 'enabled': true, 'idleTime': {'base': 5, 'display': 5, 'unit': 0}, // minutes 'transitionTime': {'base': 30, 'display': 30, 'unit': 0}, // seconds 'skip': true, 'shuffle': true, 'photoSizing': 0, 'photoTransition': 4, 'showTime': 2, // 24 hr format 'showPhotog': true, 'background': 'background:linear-gradient(to bottom, #3a3a3a, #b5bdc8)', 'keepAwake': false, 'chromeFullscreen': true, 'allDisplays': false, 'activeStart': '00:00', // 24 hr time 'activeStop': '00:00', // 24 hr time 'allowSuspend': false, 'useSpaceReddit': false, 'useEarthReddit': false, 'useAnimalReddit': false, 'useEditors500px': false, 'usePopular500px': false, 'useYesterday500px': false, 'useInterestingFlickr': false, 'useChromecast': true, 'useAuthors': false, 'useGoogle': true, 'albumSelections': [], }; /** * Set state based on screensaver enabled flag * Note: this does not effect the keep awake settings so you could * use the extension as a display keep awake scheduler without * using the screensaver * @private * @memberOf app.Data */ function _processEnabled() { // update context menu text const label = app.Storage.getBool('enabled') ? app.Utils.localize('disable') : app.Utils.localize('enable'); app.Alarm.updateBadgeText(); chromep.contextMenus.update('ENABLE_MENU', { title: label, }).catch(() =&gt; {}); } /** * Set power scheduling features * @private * @memberOf app.Data */ function _processKeepAwake() { app.Storage.getBool('keepAwake') ? chrome.power.requestKeepAwake('display') : chrome.power.releaseKeepAwake(); app.Alarm.updateRepeatingAlarms(); app.Alarm.updateBadgeText(); } /** * Set wait time for screen saver display after machine is idle * @private * @memberOf app.Data */ function _processIdleTime() { chrome.idle.setDetectionInterval(app.Utils.getIdleSeconds()); } /** * Get default time format based on locale * @returns {int} 12 or 24 * @private * @memberOf app.Data */ function _getTimeFormat() { let ret = 2; // 24 hr const format = app.Utils.localize('time_format'); if (format &amp;&amp; (format === '12')) { ret = 1; } return ret; } /** * Set the 'os' value * @returns {Promise} err on failure * @private * @memberOf app.Data */ function _setOS() { return chromep.runtime.getPlatformInfo().then((info) =&gt; { app.Storage.set('os', info.os); return Promise.resolve(); }); } /** * Save the [_DEF_VALUES]{@link app.Data._DEF_VALUES} items, if they * do not already exist * @private * @memberOf app.Data */ function _addDefaults() { Object.keys(_DEF_VALUES).forEach(function(key) { if (app.Storage.get(key) === null) { app.Storage.set(key, _DEF_VALUES[key]); } }); } /** * Convert a setting-slider value due to addition of units * @param {!string} key - localStorage key * @private * @memberOf app.Data */ function _convertSliderValue(key) { const value = app.Storage.get(key); if (value) { const newValue = { base: value, display: value, unit: 0, }; app.Storage.set(key, newValue); } } return { /** * Initialize the data saved in localStorage * @memberOf app.Data */ initialize: function() { _addDefaults(); // set operating system _setOS().catch(() =&gt; {}); // set time format based on locale app.Storage.set('showTime', _getTimeFormat()); // update state app.Data.processState(); }, /** * Update the data saved in localStorage * @memberOf app.Data */ update: function() { // New items, changes, and removal of unused items can take place // here when the version changes const oldVersion = app.Storage.getInt('version'); if (_DATA_VERSION &gt; oldVersion) { // update version number app.Storage.set('version', _DATA_VERSION); } if (oldVersion &lt; 10) { // was setting this without quotes before const oldOS = localStorage.getItem('os'); if (oldOS) { app.Storage.set('os', oldOS); } } if (oldVersion &lt; 8) { // change setting-slider values due to adding units _convertSliderValue('transitionTime'); _convertSliderValue('idleTime'); } _addDefaults(); // update state app.Data.processState(); }, /** * Restore default values for data saved in localStorage * @memberOf app.Data */ restoreDefaults: function() { Object.keys(_DEF_VALUES).forEach(function(key) { if ((key !== 'useGoogle') &amp;&amp; (key !== 'albumSelections')) { // skip Google photos settings app.Storage.set(key, _DEF_VALUES[key]); } }); // restore default time format based on locale app.Storage.set('showTime', _getTimeFormat()); // update state app.Data.processState(); }, /** * Process changes to localStorage items * @param {string} [key='all'] - the item that changed * @memberOf app.Data */ processState: function(key='all') { // Map processing functions to localStorage values const STATE_MAP = { 'enabled': _processEnabled, 'keepAwake': _processKeepAwake, 'activeStart': _processKeepAwake, 'activeStop': _processKeepAwake, 'allowSuspend': _processKeepAwake, 'idleTime': _processIdleTime, }; const noop = function() {}; let fn; if (key === 'all') { // process everything Object.keys(STATE_MAP).forEach(function(ky) { fn = STATE_MAP[ky]; return fn(); }); // process photo SOURCES app.PhotoSource.processAll(); // set os, if not already if (!app.Storage.get('os')) { _setOS().catch(() =&gt; {}); } } else { // individual change if (app.PhotoSource.contains(key)) { app.PhotoSource.process(key).catch(() =&gt; {}); } else { (STATE_MAP[key] || noop)(); } } }, }; })(); Ã— Search results Close "},"flickr.js.html":{"id":"flickr.js.html","title":"Source: flickr.js","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Source: flickr.js /* * Copyright (c) 2015-2017, Michael A. Updike All rights reserved. * Licensed under the BSD-3-Clause * https://opensource.org/licenses/BSD-3-Clause * https://github.com/opus1269/photo-screen-saver/blob/master/LICENSE.md */ window.app = window.app || {}; app.Flickr = (function() { 'use strict'; /** * Interface to flickr API * @namespace app.Flickr */ /** * Flickr rest API * @type {string} * @const * @default * @private * @memberOf app.Flickr */ const _URL_BASE = 'https://api.flickr.com/services/rest/'; /** * Flickr rest API authorization key * @type {string} * @const * @private * @memberOf app.Flickr */ const _KEY = '1edd9926740f0e0d01d4ecd42de60ac6'; /** * Max photos to return * @type {int} * @const * @default * @private * @memberOf app.Flickr */ const _MAX_PHOTOS = 300; return { /** * Retrieve flickr photos * @returns {Promise&lt;Photo[]&gt;} Array of {@link Photo} objects * @memberOf app.Flickr */ loadImages: function() { const url = `${_URL_BASE}?method=flickr.interestingness.getList` + `&amp;api_key=${_KEY}&amp;extras=owner_name,url_k,media` + `&amp;per_page=${_MAX_PHOTOS}&amp;format=json&amp;nojsoncallback=1`; return app.Http.doGet(url).then((response) =&gt; { if (response.stat !== 'ok') { throw new Error(response.message); } const photos = []; for (let i = 0; i &lt; response.photos.photo.length; i++) { const photo = response.photos.photo[i]; if (photo &amp;&amp; photo.url_k &amp;&amp; (photo.media === 'photo') &amp;&amp; (photo.isfriend !== '0') &amp;&amp; (photo.isfamily !== '0')) { const width = parseInt(photo.width_k, 10); const height = parseInt(photo.height_k, 10); const asp = width / height; app.Utils.addImage(photos, photo.url_k, photo.ownername, asp, photo.owner); } } return Promise.resolve(photos); }); }, }; })(); Ã— Search results Close "},"google_photos.js.html":{"id":"google_photos.js.html","title":"Source: google_photos.js","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Source: google_photos.js /* * Copyright (c) 2015-2017, Michael A. Updike All rights reserved. * Licensed under the BSD-3-Clause * https://opensource.org/licenses/BSD-3-Clause * https://github.com/opus1269/photo-screen-saver/blob/master/LICENSE.md */ window.app = window.app || {}; app.GooglePhotos = (function() { 'use strict'; /** * Interface to Picasa API * @namespace app.GooglePhotos */ /** * Path to Picasa API * @type {string} * @const * @default * @private * @memberOf app.GooglePhotos */ const _URL_BASE = 'https://picasaweb.google.com/data/feed/api/user/'; /** * Query an album * @type {string} * @const * @default * @private * @memberOf app.GooglePhotos */ const _ALBUM_QUERY = '?imgmax=1600&amp;thumbsize=72' + '&amp;fields=title,gphoto:id,entry(media:group/media:content,' + 'media:group/media:credit,media:group/media:thumbnail)&amp;v=2&amp;alt=json'; /** Determine if a Picasa entry is an image * @param {Object} entry - Picasa media object * @returns {boolean} true if entry is a photo * @private * @memberOf app.GooglePhotos */ function _isImage(entry) { const content = entry.media$group.media$content; for (let i = 0; i &lt; content.length; i++) { if (content[i].medium !== 'image') { return false; } } return true; } /** * Extract the Picasa photos into an Array * @param {Object} root - root object from Picasa API call * @returns {Array} Array of photo objects * @private * @memberOf app.GooglePhotos */ function _processPhotos(root) { const feed = root.feed; const entries = feed.entry || []; const photos = []; for (let i = 0; i &lt; entries.length; i++) { let entry = entries[i]; if (_isImage(entry)) { const url = entry.media$group.media$content[0].url; const width = entry.media$group.media$content[0].width; const height = entry.media$group.media$content[0].height; const asp = width / height; const author = entry.media$group.media$credit[0].$t; app.Utils.addImage(photos, url, author, asp); } } return photos; } /** * Retrieve a Google Photos album * @param {string} albumId - Picasa album ID * @param {string} [userId='default'] - userId for non-authenticated request * @returns {Promise&lt;Object&gt;} Root object from Picasa call * @private * @memberOf app.GooglePhotos */ function _loadPicasaAlbum(albumId, userId = 'default') { const url = `${_URL_BASE}${userId}/albumid/${albumId}/${_ALBUM_QUERY}`; let isAuth = false; let isRetry = false; if (userId === 'default') { isRetry = true; isAuth = true; } return app.Http.doGet(url, isAuth, isRetry); } return { /** * Get my photo album * @returns {Promise&lt;Photo[]&gt;} Array of {@link Photo} objects * @memberOf app.GooglePhotos */ loadAuthorImages: function() { const albumId = '6117481612859013089'; const userId = '103839696200462383083'; return _loadPicasaAlbum(albumId, userId).then((root) =&gt; { const photos = _processPhotos(root); if (photos &amp;&amp; photos.length) { return Promise.resolve(photos); } throw new Error('No photos'); }); }, /** * Retrieve the users list of albums, including the photos in each * @returns {Promise&lt;Array&gt;} Array of Arrays * @memberOf app.GooglePhotos */ loadAlbumList: function() { const query = '?v=2' + '&amp;fields=entry(gphoto:albumType,gphoto:id)' + '&amp;max-results=20000&amp;visibility=all&amp;kind=album&amp;alt=json'; const url = `${_URL_BASE}default/${query}`; // get list of albums return app.Http.doGet(url, true, false).then((root) =&gt; { const feed = root.feed; const entries = feed.entry || []; // series of API calls to get each album const promises = []; for (let i = 0; i &lt; entries.length; i++) { const entry = entries[i]; if (!entry.gphoto$albumType) { const albumId = entry.gphoto$id.$t; promises.push( _loadPicasaAlbum(albumId).catch(() =&gt; {}) ); } } // Collate the albums return Promise.all(promises).then((values) =&gt; { let albums = []; let ct = 0; values.forEach((value) =&gt; { const feed = value.feed; const thumb = feed.entry[0].media$group.media$thumbnail[0].url; const photos = _processPhotos(value); if (photos &amp;&amp; photos.length) { const album = { index: ct, uid: 'album' + ct, name: feed.title.$t, id: feed.gphoto$id.$t, ct: photos.length, thumb: thumb, checked: false, photos: photos, }; albums.push(album); ct++; } }); return Promise.resolve(albums); }); }); }, /** * Retrieve the photos in the selected albums * Array of Array of album photos on success * @returns {Promise&lt;Array&gt;} Array of Array of albums * @memberOf app.GooglePhotos */ loadImages: function() { const items = app.Storage.get('albumSelections'); // series of API calls to get each album const promises = []; for (let i = 0; i &lt; items.length; i++) { const albumId = items[i].id; promises.push(_loadPicasaAlbum(albumId).catch(() =&gt;{})); } // Collate the albums return Promise.all(promises).then((values) =&gt; { const albums = []; values.forEach((value) =&gt; { const feed = value.feed; const photos = _processPhotos(value); if (photos &amp;&amp; photos.length) { albums.push({id: feed.gphoto$id.$t, photos: photos}); } }); return Promise.resolve(albums); }); }, }; })(); Ã— Search results Close "},"http.js.html":{"id":"http.js.html","title":"Source: http.js","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Source: http.js /* * Copyright (c) 2015-2017, Michael A. Updike All rights reserved. * Licensed under the BSD-3-Clause * https://opensource.org/licenses/BSD-3-Clause * https://github.com/opus1269/photo-screen-saver/blob/master/LICENSE.md */ window.app = window.app || {}; app.Http = (function() { 'use strict'; /** * Fetch with authentication and exponential backoff * @namespace app.Http */ const chromep = new ChromePromise(); /** * Max retries on 500 errors * @const * @default * @private * @memberOf app.Http */ const _MAX_RETRIES = 4; /** * Delay multiplier for exponential back-off * @const * @default * @private * @memberOf app.Http */ const _DELAY = 1000; /** * Retry call to server after removing cached auth token * @param {string} url - url to call * @param {string} authToken - chrome authorization token * @returns {Promise.&lt;void&gt;} response from server * @private * @memberOf app.Http */ function _retryGet(url, authToken) { return chromep.identity.removeCachedAuthToken({ token: authToken, }).then(() =&gt; { return app.Http.doGet(url, true, false); }); } /** * Get auth token if requested * @param {boolean} isAuth - true if authorization required * @param {boolean} interactive - true if auth call is interactive * @returns {Promise.&lt;string&gt;} auth token if needed * @private * @memberOf app.Http */ function _doAuth(isAuth, interactive) { if (isAuth) { return chromep.identity.getAuthToken({'interactive': interactive}); } else { return Promise.resolve(''); } } return { /** * Perform GET request to server using exponential back-off * @param {string} url - server * @param {boolean} [isAuth=false] - true if authorization required * @param {boolean} [retryAuth=false] - if true, retry with new token * @returns {Promise.&lt;json&gt;} response from server * @memberOf app.Http */ doGet: function(url, isAuth = false, retryAuth = false) { let attempts = 0; let token = ''; return _doGet(); /** * Fetch with exponential back-off * @returns {Promise.&lt;json&gt;} response from server * @memberOf app.Http */ function _doGet() { return _doAuth(isAuth, retryAuth).then((authToken) =&gt; { const init = {method: 'GET', headers: new Headers({})}; if (isAuth) { token = authToken; init.headers.append('Authorization', `Bearer ${token}`); } return fetch(url, init); }).then((response) =&gt; { if (response.ok) { return response.json(); } else if (isAuth &amp;&amp; retryAuth &amp;&amp; (response.status === 401)) { // could be bad token. Remove cached one and try again return _retryGet(url, token); } else if ((attempts &lt; _MAX_RETRIES) &amp;&amp; ((response.status &gt;= 500) &amp;&amp; (response.status &lt; 600))) { // temporary server issue, retryAuth with back-off attempts++; const delay = (Math.pow(2, attempts) - 1) * _DELAY; return new Promise(() =&gt; { setTimeout(() =&gt; { return _doGet(); }, delay); }); } else { // TODO add to localization let msg = `Status: ${response.status}`; msg+= `\\nReason: ${response.statusText}`; throw new Error(msg); } }).then((json) =&gt; { return Promise.resolve(json); }); } }, }; })(); Ã— Search results Close "},"options.js.html":{"id":"options.js.html","title":"Source: options.js","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Source: options.js /* * Copyright (c) 2015-2017, Michael A. Updike All rights reserved. * Licensed under the BSD-3-Clause * https://opensource.org/licenses/BSD-3-Clause * https://github.com/opus1269/photo-screen-saver/blob/master/LICENSE.md */ (function(document) { 'use strict'; /** * Extension's Options page * @namespace app.Options */ const chromep = new ChromePromise(); /** * Manage an html page that is inserted on demand&lt;br /&gt; * May also be a url link to external site * @typedef {Object} app.Options.Page * @property {string} label - label for Nav menu * @property {string} route - element name route to page * @property {string} icon - icon for Nav Menu * @property {?Object} obj - something to be done when selected * @property {boolean} ready - true if html is inserted * @property {boolean} divider - true for divider before item * @memberOf app.Options */ /** * Path to the extension in the Web Store * @type {string} * @const * @private * @memberOf app.Options */ const EXT_URI = 'https://chrome.google.com/webstore/detail/photo-screen-saver/' + chrome.runtime.id + '/'; /** * Path to my Pushy Clipboard extension * @type {string} * @const * @default * @private * @memberOf app.Options */ const PUSHY_URI = 'https://chrome.google.com/webstore/detail/pushy-clipboard/' + 'jemdfhaheennfkehopbpkephjlednffd'; /** * auto-binding template * @type {Object} * @const * @private * @memberOf app.Options */ const t = document.querySelector('#t'); // Error dialog t.dialogTitle = ''; t.dialogText = ''; // current and previous route // several menu items open a new tab or window and we // need to keep the selected menu item and the current page in sync t.route = 'page-settings'; t.prevRoute = 'page-settings'; /** * Computed property: Page title * @returns {string} i18n title * @memberOf app.Options */ t.computeTitle = function() { return app.Utils.localize('chrome_extension_name'); }; /** * Computed property: Menu label * @returns {string} i18n label * @memberOf app.Options */ t.computeMenu = function() { return app.Utils.localize('menu'); }; /** * Event Listener for template bound event to know when bindings * have resolved and content has been stamped to the page * @memberOf app.Options */ t.addEventListener('dom-change', function() { // listen for app messages chrome.runtime.onMessage.addListener(t.onMessage); }); /** * Event Listener for main menu clicks * Route to proper page * @param {Event} event - ClickEvent * @memberOf app.Options */ t.onDataRouteClick = function(event) { // Close drawer after menu item is selected if drawerPanel is narrow t.closeDrawer(); const index = t.pages.map(function(e) { return e.route; }).indexOf(event.currentTarget.id); t.prevRoute = t.route; if (!t.pages[index].obj) { // some pages are just pages t.route = t.pages[index].route; t.scrollPageToTop(); } else if (typeof t.pages[index].obj === 'string') { // some pages are url links t.$.mainMenu.select(t.prevRoute); chrome.tabs.create({url: t.pages[index].obj}); } else { // some pages have functions to view them t.pages[index].obj(index, event); } }; /** * Show the Google Photos page * @param {int} index index into [t.pages]{@link app.Options.t.pages} * @memberOf app.Options */ t.googlePhotos = function(index) { if (!t.pages[index].ready) { // create the page the first time t.pages[index].ready = true; t.gPhotosPage = new app.GooglePhotosPage('gPhotosPage', t.$.errorDialog, t.$.dialogTitle, t.$.dialogText); Polymer.dom(t.$.googlePhotosInsertion).appendChild(t.gPhotosPage); } else { t.gPhotosPage.loadAlbumList(); } t.route = t.pages[index].route; t.scrollPageToTop(); }; /** * Show the help page * @param {int} index - index into [t.pages]{@link app.Options.t.pages} * @private * @memberOf app.Options */ function _showHelpPage(index) { if (!t.pages[index].ready) { // insert the page the first time t.pages[index].ready = true; const el = new app.HelpPageFactory(); Polymer.dom(t.$.helpInsertion).appendChild(el); } t.route = t.pages[index].route; t.scrollPageToTop(); } /** * Show the Help page * @param {int} index - index into [t.pages]{@link app.Options.t.pages} * @memberOf app.Options */ t.help = function(index) { if (!t.pages[index].ready) { // create the page the first time t.pages[index].ready = true; const el = new app.HelpPage(); Polymer.dom(t.$.infoInsertion).appendChild(el); } t.route = t.pages[index].route; t.scrollPageToTop(); }; /** * Display a preview of the screen saver * @memberOf app.Options */ t.preview = function() { // reselect previous page t.async(function() { t.$.mainMenu.select(t.prevRoute); }, 500); chromep.runtime.sendMessage({ message: 'showScreensaver', }).catch((err) =&gt; {}); }; /** * Array of pages * @type {app.Options.Page[]} * @memberOf app.Options */ t.pages = [ { label: app.Utils.localize('menu_settings'), route: 'page-settings', icon: 'myicons:settings', obj: null, ready: true, divider: false, }, { label: app.Utils.localize('menu_google'), route: 'page-google-photos', icon: 'myicons:cloud', obj: t.googlePhotos, ready: false, divider: false, }, { label: app.Utils.localize('menu_preview'), route: 'page-preview', icon: 'myicons:pageview', obj: t.preview, ready: true, divider: false, }, { label: app.Utils.localize('menu_help'), route: 'page-help', icon: 'myicons:help', obj: _showHelpPage, ready: false, divider: false, }, { label: app.Utils.localize('menu_support'), route: 'page-support', icon: 'myicons:help', obj: `${EXT_URI}support`, ready: true, divider: true, }, { label: app.Utils.localize('menu_rate'), route: 'page-rate', icon: 'myicons:grade', obj: `${EXT_URI}reviews`, ready: true, divider: false, }, { label: app.Utils.localize('menu_pushy'), route: 'page-pushy', icon: 'myicons:extension', obj: PUSHY_URI, ready: true, divider: true, }, ]; /** * Scroll page to top * @memberOf app.Options */ t.scrollPageToTop = function() { t.$.scrollPanel.scrollToTop(true); }; /** * Close drawer if drawerPanel is narrow * @memberOf app.Options */ t.closeDrawer = function() { const drawerPanel = document.querySelector('#paperDrawerPanel'); if (drawerPanel.narrow) { drawerPanel.closeDrawer(); } }; /** * Event: Fired when a message is sent from either an extension process&lt;br&gt; * (by runtime.sendMessage) or a content script (by tabs.sendMessage). * @see https://developer.chrome.com/extensions/runtime#event-onMessage * @param {Object} request - details for the message * @param {string} request.message - name of the message * @param {Object} sender - MessageSender object * @param {function} response - function to call once after processing * @returns {boolean} true if asynchronous * @private * @memberOf app.Options */ t.onMessage = function(request, sender, response) { if (request.message === 'highlight') { // highlight ourselves and let the sender know we are here chromep.tabs.getCurrent().then((t) =&gt; { chrome.tabs.update(t.id, {'highlighted': true}); }).catch((err) =&gt; {}); response(JSON.stringify({message: 'OK'})); } else if (request.message === 'storageExceeded') { // Display Error Dialog if a save action exceeded the // localStorage limit t.dialogTitle = app.Utils.localize('err_storage_title'); t.dialogText = app.Utils.localize('err_storage_desc'); t.$.errorDialog.open(); } return true; }; })(document); Ã— Search results Close "},"photo_view.js.html":{"id":"photo_view.js.html","title":"Source: photo_view.js","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Source: photo_view.js /* * Copyright (c) 2015-2017, Michael A. Updike All rights reserved. * Licensed under the BSD-3-Clause * https://opensource.org/licenses/BSD-3-Clause * https://github.com/opus1269/photo-screen-saver/blob/master/LICENSE.md */ window.app = window.app || {}; app.PhotoView = (function() { 'use strict'; /** * Handle rendering of a photo in screen saver * @namespace app.PhotoView */ /** * Important components of a photo view * @typedef {Object} Elements * @property {Element} image - paper-image * @property {Element} author - label * @property {Element} time - label * @property {Object} model - template model * @property {Object} item - photo item * @memberOf app.PhotoView */ /** * Aspect ratio of screen * @type {number} * @const * @private * @memberOf app.PhotoView */ const SCREEN_ASPECT = screen.width / screen.height; /** * Get references to the important elements of a slide * @param {int} idx - index into animated pages * @returns {Elements} Object containing the elements of a slide * @private * @memberOf app.PhotoView */ function _getElements(idx) { const rep = document.querySelector('#repeatTemplate'); const pages = document.querySelector('#pages'); const el = pages.querySelector('#item' + idx); const ret = {}; ret.image = el.querySelector('.image'); ret.author = el.querySelector('.author'); ret.time = el.querySelector('.time'); ret.model = rep.modelForElement(ret.image); ret.item = ret.model.get('item'); return ret; } /** * Finalize DOM for a letter boxed photo * @param {int} idx - index into animated pages * @private * @memberOf app.PhotoView */ function _letterbox(idx) { const e = _getElements(idx); const aspect = e.item.aspectRatio; let right; let bottom; if (aspect &lt; SCREEN_ASPECT) { right = (100 - aspect / SCREEN_ASPECT * 100) / 2; e.author.style.right = (right + 1) + 'vw'; e.author.style.bottom = ''; e.time.style.right = (right + 1) + 'vw'; e.time.style.bottom = ''; } else { bottom = (100 - SCREEN_ASPECT / aspect * 100) / 2; e.author.style.bottom = (bottom + 1) + 'vh'; e.author.style.right = ''; e.time.style.bottom = (bottom + 3.5) + 'vh'; e.time.style.right = ''; } } /** * Finalize DOM for a stretched photo * @param {int} idx - index into animated pages * @private * @memberOf app.PhotoView */ function _stretch(idx) { const e = _getElements(idx); const img = e.image.$.img; img.style.width = '100%'; img.style.height = '100%'; img.style.objectFit = 'fill'; } /** * Finalize DOM for a framed photo * @param {int} idx - index into animated pages * @private * @memberOf app.PhotoView */ function _frame(idx) { const e = _getElements(idx); const model = e.model; const author = e.author; const time = e.time; const image = e.image; const img = image.$.img; const photo = e.item; const aspect = photo.aspectRatio; let padding; let border; let borderBot; let width; let height; let frWidth; let frHeight; // scale to screen size border = screen.height * 0.005; borderBot = screen.height * 0.05; padding = screen.height * 0.025; if (!app.Storage.getBool('showPhotog')) { // force use of photo label for this view const label = photo.buildLabel(true); model.set('item.label', label); } height = Math.min((screen.width - padding * 2 - border * 2) / aspect, screen.height - padding * 2 - border - borderBot); width = height * aspect; // size with the frame frWidth = width + border * 2; frHeight = height + borderBot + border; img.style.height = height + 'px'; img.style.width = width + 'px'; image.height = height; image.width = width; image.style.top = (screen.height - frHeight) / 2 + 'px'; image.style.left = (screen.width - frWidth) / 2 + 'px'; image.style.border = 0.5 + 'vh ridge WhiteSmoke'; image.style.borderBottom = 5 + 'vh solid WhiteSmoke'; image.style.borderRadius = '1.5vh'; image.style.boxShadow = '1.5vh 1.5vh 1.5vh rgba(0,0,0,.7)'; if (app.Storage.getInt('showTime')) { author.style.left = (screen.width - frWidth) / 2 + 10 + 'px'; author.style.textAlign = 'left'; } else { author.style.left = '0'; author.style.width = screen.width + 'px'; author.style.textAlign = 'center'; } author.style.bottom = (screen.height - frHeight) / 2 + 10 + 'px'; author.style.color = 'black'; author.style.opacity = 0.9; author.style.fontSize = '2.5vh'; author.style.fontWeight = 300; time.style.right = (screen.width - frWidth) / 2 + 10 + 'px'; time.style.textAlign = 'right'; time.style.bottom = (screen.height - frHeight) / 2 + 10 + 'px'; time.style.color = 'black'; time.style.opacity = 0.9; time.style.fontSize = '3vh'; time.style.fontWeight = 300; } /** * Add superscript to the label for 500px photos * @param {int} idx - index into animated pages * @memberOf app.PhotoView * @private */ function _super500px(idx) { const e = _getElements(idx); const sup = e.author.querySelector('#sup'); (e.item.type === '500') ? sup.textContent = 'px' : sup.textContent = ''; } return { /** * Get the name of the photo in this view * @param {int} idx - index into animated pages * @returns {string} name of photo * @memberOf app.PhotoView */ getName: function(idx) { const e = _getElements(idx); return e.item.name; }, /** * Finalize DOM for a photo * @param {int} idx - index into animated pages * @param {Object} t - Polymer template * @memberOf app.PhotoView */ prep: function(idx, t) { app.PhotoView.setTime(t); _super500px(idx); switch (t.photoSizing) { case 0: _letterbox(idx); break; case 2: _frame(idx); break; case 3: _stretch(idx); break; default: break; } }, /** * Determine if a photo failed to load (usually 404 error) * @param {int} idx - index into animated pages * @returns {boolean} true if image load failed * @memberOf app.PhotoView */ isError: function(idx) { const e = _getElements(idx); return !e.image || e.image.error; }, /** * Determine if a photo has finished loading * @param {int} idx - index into animated pages * @returns {boolean} true if image is loaded * @memberOf app.PhotoView */ isLoaded: function(idx) { const e = _getElements(idx); return !!e.image &amp;&amp; e.image.loaded; }, /** * Build and set the time string * @param {Object} t - Polymer template * @memberOf app.PhotoView */ setTime: function(t) { const format = app.Storage.getInt('showTime'); const date = new Date(); let timeStr; if (format === 0) { // don't show time timeStr = ''; } else if (format === 1) { // 12 hour format timeStr = date.toLocaleTimeString('en-us', { hour: 'numeric', minute: '2-digit', hour12: true, }); if (timeStr.endsWith('M')) { // strip off AM/PM timeStr = timeStr.substring(0, timeStr.length - 3); } } else { // 24 hour format timeStr = date.toLocaleTimeString(navigator.language, { hour: 'numeric', minute: '2-digit', hour12: false, }); } t.set('time', timeStr); }, }; })(); Ã— Search results Close "},"reddit.js.html":{"id":"reddit.js.html","title":"Source: reddit.js","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Source: reddit.js /* * Copyright (c) 2015-2017, Michael A. Updike All rights reserved. * Licensed under the BSD-3-Clause * https://opensource.org/licenses/BSD-3-Clause * https://github.com/opus1269/photo-screen-saver/blob/master/LICENSE.md */ window.app = window.app || {}; app.Reddit = (function() { 'use strict'; /** * Interface to Reddit API * @namespace app.Reddit */ /** * Extension's redirect uri * @type {string} * @const * @private * @memberOf app.Reddit */ const _REDIRECT_URI = `https://${chrome.runtime.id}.chromiumapp.org/reddit`; /** * Reddit rest API authorization key * @type {string} * @const * @private * @memberOf app.Reddit */ const _KEY = 'bATkDOUNW_tOlg'; /** * Max photos to return * @type {int} * @const * @default * @private * @memberOf app.Reddit */ const _MAX_PHOTOS = 100; /** * Min size of photo to use * @type {int} * @const * @default * @private * @memberOf app.Reddit */ const _MIN_SIZE = 750; /** * Max size of photo to use * @type {int} * @const * @default * @private * @memberOf app.Reddit */ const _MAX_SIZE = 3500; /** * Expose reddit API * @type {Function} * @const * @private * @memberOf app.Reddit */ const _snoocore = new Snoocore({ userAgent: 'photo-screen-saver', throttle: 0, oauth: { type: 'implicit', key: _KEY, redirectUri: _REDIRECT_URI, scope: ['read'], }, }); /** * Parse the size from the submission title. * this is the old way reddit did it * @param {string} title - submission title * @returns {{width: int, height: int}} Photo size * @private * @memberOf app.Reddit */ function _getSize(title) { const ret = {width: -1, height: -1}; const regex = /\\[(\\d*)\\D*(\\d*)\\]/; const res = title.match(regex); if (res) { ret.width = parseInt(res[1], 10); ret.height = parseInt(res[2], 10); } return ret; } /** * Build the list of photos for one page of items * @param {Array} children - Array of photos returned from reddit * @returns {Array} Array of {@link Photo} objects, * stripped of NSFW and big and small photos * @private * @memberOf app.Reddit */ function _processChildren(children) { const photos = []; let url; let width = 1; let height = 1; for (let i = 0; i &lt; children.length; i++) { const data = children[i].data; if (data.over_18) { // skip NSFW continue; } else if (data.preview &amp;&amp; data.preview.images) { // new way. has full size image and array of reduced resolutions let item = data.preview.images[0]; url = item.source.url; width = parseInt(item.source.width, 10); height = parseInt(item.source.height, 10); if (Math.max(width, height) &gt; _MAX_SIZE) { // too big. get the largest reduced resolution image item = item.resolutions[item.resolutions.length - 1]; url = item.url.replace(/&amp;amp;/g, '&amp;'); width = parseInt(item.width, 10); height = parseInt(item.height, 10); } } else if (data.title) { // old way of specifying images const size = _getSize(data.title); url = data.url; width = size.width; height = size.height; } const asp = width / height; if (asp &amp;&amp; !isNaN(asp) &amp;&amp; (Math.max(width, height) &gt;= _MIN_SIZE) &amp;&amp; (Math.max(width, height) &lt;= _MAX_SIZE)) { app.Utils.addImage(photos, url, data.author, asp, data.url); } } return photos; } return { /** * Retrieve the array of reddit photos * @param {string} subreddit - name of photo subreddit * @returns {Promise&lt;Photo[]&gt;} Array of {@link Photo} objects * @memberOf app.Reddit */ loadImages: function(subreddit) { let photos = []; return _snoocore(`${subreddit}hot`).listing({ limit: _MAX_PHOTOS, }).then((slice) =&gt; { photos = photos.concat(_processChildren(slice.children)); return slice.next(); }).then((slice) =&gt; { photos = photos.concat(_processChildren(slice.children)); return Promise.resolve(photos); }); }, }; })(); Ã— Search results Close "},"screensaver.js.html":{"id":"screensaver.js.html","title":"Source: screensaver.js","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Source: screensaver.js /* * Copyright (c) 2015-2017, Michael A. Updike All rights reserved. * Licensed under the BSD-3-Clause * https://opensource.org/licenses/BSD-3-Clause * https://github.com/opus1269/photo-screen-saver/blob/master/LICENSE.md */ /* @@license */ (function() { 'use strict'; /** * Display a screen saver * @namespace app.ScreenSaver */ const chromep = new ChromePromise(); /** * aspect ratio of screen * @type {number} * @const * @private * @memberOf app.ScreenSaver */ const SCREEN_ASPECT = screen.width / screen.height; /** * max number of animated pages * @type {int} * @const * @default * @private * @memberOf app.ScreenSaver */ const MAX_PAGES = 20; /** * repeating alarm for updating time label * @type {string} * @const * @default * @private * @memberOf app.ScreenSaver */ const CLOCK_ALARM = 'updateTimeLabel'; // set selected background image document.body.style.background = app.Storage.get('background').substring(11); /** * main auto-bind template * @type {Object} * @const * @private * @memberOf app.ScreenSaver */ const t = document.querySelector('#t'); // repeat template t.rep = null; // neon-animated-pages element t.p = null; /** * array of all the photos to use for slide show * @type {Array} * @memberOf app.ScreenSaver */ t.itemsAll = []; /** * Index into [t.itemsAll]{@link app.ScreenSaver.t.itemsAll} * @type {int} * @memberOf app.ScreenSaver */ t.curIdx = 0; /** * Array of photos [MAX_PAGES]{@link app.ScreenSaver.MAX_PAGES} * long, currently loaded into the neon-animated-pages. * Always changing subset of [t.itemsAll]{@link app.ScreenSaver.t.itemsAll} * @type {Array} * @memberOf app.ScreenSaver */ t.items = []; // the last selected page t.lastSelected = -1; // true after first full page animation t.started = false; // Flag to indicate the screen saver has no photos t.noPhotos = false; // Starting mouse position t.startMouse = {x: null, y: null}; /** * Event Listener for template bound event to know when bindings * have resolved and content has been stamped to the page * @memberOf app.ScreenSaver */ t.addEventListener('dom-change', function() { t.rep = t.$.repeatTemplate; t.p = t.$.pages; t.time = 'time'; t.processZoom(); t.processPhotoTransitions(); t.processPhotoSizing(); // listen for request to close screensaver chrome.runtime.onMessage.addListener(t.onMessage); // load the photos for the slide show t.loadImages(); if (!t.noPhotos) { // kick off the slide show if there are photos selected // slight delay at beginning so we have a smooth start t.waitTime = 2000; t.timer = window.setTimeout(t.runShow, t.waitTime); } }); /** * Process Chrome window Zoom factor * @memberOf app.ScreenSaver */ t.processZoom = function() { if (app.Utils.getChromeVersion() &gt;= 42) { // override zoom factor to 1.0 - chrome 42 and later chromep.tabs.getZoom().then((zoomFactor) =&gt; { if ((zoomFactor &lt;= 0.99) || (zoomFactor &gt;= 1.01)) { chrome.tabs.setZoom(1.0); } }).catch((err) =&gt; {}); } }; /** * Process settings related to between photo transition * @memberOf app.ScreenSaver */ t.processPhotoTransitions = function() { t.transitionType = app.Storage.getInt('photoTransition'); if (t.transitionType === 8) { // pick random transition t.transitionType = app.Utils.getRandomInt(0, 7); } const trans = app.Storage.get('transitionTime'); t.transitionTime = trans.base * 1000; t.waitTime = t.transitionTime; t.waitForLoad = true; const showTime = app.Storage.getInt('showTime'); if ((showTime !== 0) &amp;&amp; (trans.base &gt; 60)) { // add repeating alarm to update time label // if transition time is more than 1 minute // and time label is showing chrome.alarms.onAlarm.addListener(t.onAlarm); chromep.alarms.get(CLOCK_ALARM).then((alarm) =&gt; { if (!alarm) { chrome.alarms.create(CLOCK_ALARM, { when: Date.now(), periodInMinutes: 1, }); } }).catch((err) =&gt; {}); } }; /** * Process settings related to photo appearance * @memberOf app.ScreenSaver */ t.processPhotoSizing = function() { t.photoSizing = app.Storage.getInt('photoSizing'); if (t.photoSizing === 4) { // pick random sizing t.photoSizing = app.Utils.getRandomInt(0, 3); } switch (t.photoSizing) { case 0: t.sizingType = 'contain'; break; case 1: t.sizingType = 'cover'; break; case 2: case 3: t.sizingType = null; break; default: break; } }; /** * Build the Array of photos that will be displayed * and populate the neon-animated-pages * @memberOf app.ScreenSaver */ t.loadImages = function() { let count = 0; const arr = app.PhotoSource.getSelectedPhotos(); if (app.Storage.getBool('shuffle')) { // randomize the order app.Utils.shuffleArray(arr); } for (let i = 0; i &lt; arr.length; i++) { if (!app.Photo.ignore(arr[i].asp, SCREEN_ASPECT, t.photoSizing)) { const photo = new app.Photo('photo' + count, arr[i]); t.itemsAll.push(photo); if (count &lt; MAX_PAGES) { // add a new animatable page - shallow copy t.push('items', JSON.parse(JSON.stringify(t.itemsAll[count]))); t.curIdx++; } count++; } } if (!count) { // No usable photos, display static image t.$.noPhotos.style.visibility = 'visible'; t.noPhotos = true; } }; /** * Try to find a photo that has finished loading * @param {int} idx - index into [t.items]{@link app.ScreenSaver.t.items} * @returns {int} index into t.items of a loaded photo, * -1 if none are loaded * @memberOf app.ScreenSaver */ t.findLoadedPhoto = function(idx) { if (app.PhotoView.isLoaded(idx)) { return idx; } for (let i = idx + 1; i &lt; t.items.length; i++) { if ((i !== t.lastSelected) &amp;&amp; (i !== t.p.selected) &amp;&amp; app.PhotoView.isLoaded(i)) { return i; } } for (let i = 0; i &lt; idx; i++) { if ((i !== t.lastSelected) &amp;&amp; (i !== t.p.selected) &amp;&amp; app.PhotoView.isLoaded(i)) { return i; } } return -1; }; /** * Add the next photo from the master array * @param {int} idx - index into [t.items]{@link app.ScreenSaver.t.items} * @param {boolean} error - true if the photo at idx didn't load * @memberOf app.ScreenSaver */ t.replacePhoto = function(idx, error) { let item; if (error) { // bad url, mark it const name = app.PhotoView.getName(idx); const index = t.itemsAll.map(function(item) { return item.name; }).indexOf(name); if (index !== -1) { t.itemsAll[index].name = 'skip'; } } if (t.started &amp;&amp; (t.itemsAll.length &gt; t.items.length)) { for (let i = t.curIdx; i &lt; t.itemsAll.length; i++) { // find a url that is ok, AFAWK item = t.itemsAll[i]; if (item.name !== 'skip') { t.curIdx = i; break; } } // add the next image from the master list to this page t.rep.set('items.' + idx, JSON.parse(JSON.stringify(item))); t.curIdx = (t.curIdx === t.itemsAll.length - 1) ? 0 : t.curIdx + 1; } }; /** * Replace the active photos with new photos from the master array * @memberOf app.ScreenSaver */ t.replaceAllPhotos = function() { if (t.itemsAll.length &gt; t.items.length) { let pos = 0; let item; let newIdx = t.curIdx; for (let i = t.curIdx; i &lt; t.itemsAll.length; i++) { newIdx = i; item = t.itemsAll[i]; if (item.name !== 'skip') { if ((pos !== t.lastSelected) &amp;&amp; (pos !== t.p.selected)) { // don't replace the last two t.rep.set('items.' + pos, JSON.parse(JSON.stringify(item))); } pos++; if (pos === t.items.length) { break; } } } t.curIdx = (newIdx === t.itemsAll.length - 1) ? 0 : newIdx + 1; } }; /** * Get the next photo to display * @param {int} idx - index into [t.items]{@link app.ScreenSaver.t.items} * @returns {int} next - index into [t.items]{@link app.ScreenSaver.t.items} * to display, -1 if none are ready * @memberOf app.ScreenSaver */ t.getNextPhoto = function(idx) { let ret = t.findLoadedPhoto(idx); if (ret === -1) { if (t.waitForLoad) { // no photos ready.. wait a little and try again the first time t.waitTime = 2000; t.waitForLoad = false; } else { // tried waiting for load, now replace the current photos t.waitTime = 200; t.replaceAllPhotos(); idx = (idx === t.items.length - 1) ? 0 : idx + 1; ret = t.findLoadedPhoto(idx); } } else if (t.waitTime !== t.transitionTime) { // photo found, set the waitTime back to transition time in case // it was changed t.waitTime = t.transitionTime; } return ret; }; /** * Called at fixed time intervals to cycle through the photos * Runs forever * @memberOf app.ScreenSaver */ t.runShow = function() { const curPage = (t.p.selected === undefined) ? 0 : t.p.selected; const prevPage = (curPage &gt; 0) ? curPage - 1 : t.items.length - 1; let selected = (curPage === t.items.length - 1) ? 0 : curPage + 1; // replace the previous selected with the next one from master array t.replacePhoto(t.lastSelected, false); if (app.PhotoView.isError(prevPage)) { // broken link, mark it and replace it t.replacePhoto(prevPage, true); } if (t.p.selected === undefined) { // special case for first page. neon-animated-pages is configured // to run the entry animation for the first selection selected = curPage; } else if (!t.started) { // special case for first full animation. next time ready to start // splicing in the new images t.started = true; } selected = t.getNextPhoto(selected); if (selected !== -1) { // If a new photo is ready, prep it app.PhotoView.prep(selected, t); // update t.p.selected so the animation runs t.lastSelected = t.p.selected; t.p.selected = selected; } // setup the next timer --- runs forever t.timer = window.setTimeout(t.runShow, t.waitTime); }; /** * Event: Fired when a message is sent from either an extension process&lt;br&gt; * (by runtime.sendMessage) or a content script (by tabs.sendMessage). * @see https://developer.chrome.com/extensions/runtime#event-onMessage * @param {Object} request - details for the message * @param {Object} sender - MessageSender object * @param {function} response - function to call once after processing * @returns {boolean} true if asynchronous * @memberOf app.ScreenSaver */ t.onMessage = function(request, sender, response) { if (request.message === 'close') { t.closeWindow(); } else if(request.message === 'isShowing') { // let people know we are here response({message: 'OK'}); } return true; }; /** * Listen for alarms * @param {Object} alarm - chrome alarm * @param {string} alarm.name - alarm type * @memberOf app.ScreenSaver */ t.onAlarm = function(alarm) { if (alarm.name === CLOCK_ALARM) { // update time label if (t.p.selected !== undefined) { app.PhotoView.setTime(t); } } }; /** * Close ourselves * @memberOf app.ScreenSaver */ t.closeWindow = function() { // send message to other screen savers to close themselves chromep.runtime.sendMessage({ message: 'close', }).catch((err) =&gt; {}); setTimeout(function() { // delay a little to process events window.close(); }, 750); }; /** * Event listener for mouse clicks * Show link to original photo if possible and close windows */ window.addEventListener('click', function() { if (t.p.selected) { app.Photo.showSource(t.items[t.p.selected]); } t.closeWindow(); }, false); /** * Event listener for key press * Close window (prob won't work on Chrome OS) */ window.addEventListener('keydown', function() { t.closeWindow(); }, false); /** * Event listener for mouse move * Close window */ window.addEventListener('mousemove', function(event) { if (t.startMouse.x &amp;&amp; t.startMouse.y) { const deltaX = Math.abs(event.clientX - t.startMouse.x); const deltaY = Math.abs(event.clientY - t.startMouse.y); if (Math.max(deltaX, deltaY) &gt; 10) { // close after a minimum amount of mouse movement t.closeWindow(); } } else { // first move, set values t.startMouse.x = event.clientX; t.startMouse.y = event.clientY; } }, false); })(); Ã— Search results Close "},"ss_controller.js.html":{"id":"ss_controller.js.html","title":"Source: ss_controller.js","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Source: ss_controller.js /* * Copyright (c) 2015-2017, Michael A. Updike All rights reserved. * Licensed under the BSD-3-Clause * https://opensource.org/licenses/BSD-3-Clause * https://github.com/opus1269/photo-screen-saver/blob/master/LICENSE.md */ window.app = window.app || {}; app.SSControl = (function() { 'use strict'; /** * Controller for the screen saver * @namespace app.SSControl */ const chromep = new ChromePromise(); /** * Screensaver URL * @type {string} * @default * @const * @private * @memberOf app.SSControl */ const _SS_URL = '/html/screensaver.html'; /** * Determine if there is a full screen chrome window running on a display * @param {Object} display - a connected display * @returns {Promise&lt;boolean&gt;} true if there is a full screen * window on the display * @private * @memberOf app.SSControl */ function _hasFullscreen(display) { if (app.Storage.getBool('chromeFullscreen')) { return chromep.windows.getAll({populate: false}).then((wins) =&gt; { let ret = false; const left = display ? display.bounds.left : 0; const top = display ? display.bounds.top : 0; for (let i = 0; i &lt; wins.length; i++) { const win = wins[i]; if ((win.state === 'fullscreen') &amp;&amp; (!display || (win.top === top &amp;&amp; win.left === left))) { ret = true; break; } } return Promise.resolve(ret); }); } else { return Promise.resolve(false); } } /** * Determine if the screen saver is currently showing * @returns {Promise&lt;boolean&gt;} true if showing * @private * @memberOf app.SSControl */ function _isShowing() { // send message to the screen saver to see if he is around return chromep.runtime.sendMessage({ message: 'isShowing', }, null).then(() =&gt; { // a screensaver is around return Promise.resolve(true); }).catch(() =&gt; { // throws error if receiving end does not exist return Promise.resolve(false); }); } /** * Open a screen saver window on the given display * @param {Object} display - a connected display * @private * @memberOf app.SSControl */ function _open(display) { _hasFullscreen(display).then((isTrue) =&gt; { if (isTrue) { // don't display if there is a fullscreen window return; } // window creation options const winOpts = { url: _SS_URL, focused: true, type: 'popup', }; if (app.Utils.getChromeVersion() &gt;= 44 &amp;&amp; !display) { // Chrome supports fullscreen option on create since version 44 winOpts.state = 'fullscreen'; } else { const left = display ? display.bounds.left : 0; const top = display ? display.bounds.top : 0; winOpts.left = left; winOpts.top = top; winOpts.width = 1; winOpts.height = 1; } return chromep.windows.create(winOpts).then((win) =&gt; { if (winOpts.state !== 'fullscreen') { chrome.windows.update(win.id, {state: 'fullscreen'}); } }); }).catch((err) =&gt; {}); } /** * Open a screensaver on every display * @private * @memberOf app.SSControl */ function _openOnAllDisplays() { chromep.system.display.getInfo().then((displayInfo) =&gt; { if (displayInfo.length === 1) { _open(null); } else { for (let i = 0; i &lt; displayInfo.length; i++) { _open(displayInfo[i]); } } }).catch((err) =&gt; {}); } /** * Event: Fired when the system changes to an active, idle or locked state. * The event fires with &quot;locked&quot; if the screen is locked or the screensaver * activates, &quot;idle&quot; if the system is unlocked and the user has not * generated any input for a specified number of seconds, and &quot;active&quot; * when the user generates input on an idle system. * @see https://developer.chrome.com/extensions/idle#event-onStateChanged * @param {string} state - current state of computer * @private * @memberOf app.SSControl */ function _onIdleStateChanged(state) { _isShowing().then((isTrue) =&gt; { if (state === 'idle' &amp;&amp; app.Alarm.isActive() &amp;&amp; !isTrue) { app.SSControl.display(false); } else { if (!app.Utils.isWin()) { // Windows 10 Creator triggers an 'active' state // when the window is created so we have to skip // closing here app.SSControl.close(); } } }).catch((err) =&gt; {}); } // noinspection JSUnusedLocalSymbols /** * Event: Fired when a message is sent from either an extension process&lt;br&gt; * (by runtime.sendMessage) or a content script (by tabs.sendMessage). * @see https://developer.chrome.com/extensions/runtime#event-onMessage * @param {Object} request - details for the message * @param {string} request.message - name of the message * @param {Object} sender - MessageSender object * @param {function} response - function to call once after processing * @returns {boolean} true if asynchronous * @private * @memberOf app.SSControl */ function _onChromeMessage(request, sender, response) { if (request.message === 'showScreensaver') { // preview the screensaver app.SSControl.display(true); } return true; } // listen for changes to the idle state of the computer chrome.idle.onStateChanged.addListener(_onIdleStateChanged); // listen for chrome messages chrome.runtime.onMessage.addListener(_onChromeMessage); return { /** * Display the screen saver(s) * !Important: Always request screensaver through this call * @param {boolean} single - if true only show on one display * @memberOf app.SSControl */ display: function(single) { if (!single &amp;&amp; app.Storage.getBool('allDisplays')) { _openOnAllDisplays(); } else { _open(null); } }, /** * Close all the screen saver windows * @memberOf app.SSControl */ close: function() { // send message to the screen savers to close themselves chromep.runtime.sendMessage({ message: 'close', }).catch((err) =&gt; {}); }, }; })(); Ã— Search results Close "},"storage.js.html":{"id":"storage.js.html","title":"Source: storage.js","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Source: storage.js /* * Copyright (c) 2015-2017, Michael A. Updike All rights reserved. * Licensed under the BSD-3-Clause * https://opensource.org/licenses/BSD-3-Clause * https://github.com/opus1269/photo-screen-saver/blob/master/LICENSE.md */ window.app = window.app || {}; app.Storage = (function() { 'use strict'; /** * Manage items in localStorage * @namespace app.Storage */ return { /** * Get a JSON parsed value from localStorage * @param {!string} key - key to get value for * @returns {?JSON} JSON object, null if key does not exist * @memberOf app.Storage */ get: function(key) { let item = localStorage.getItem(key); if (item !== null) { item = JSON.parse(item); } return item; }, /** * Get integer value from localStorage * @param {!string} key - key to get value for * @returns {?int} value as integer * @memberOf app.Storage */ getInt: function(key) { let item = localStorage.getItem(key); if (item !== null) { item = parseInt(item, 10); } return item; }, /** * Get boolean value from localStorage * @param {!string} key - key to get value for * @returns {?boolean} value as boolean * @memberOf app.Storage */ getBool: function(key) { return app.Storage.get(key); }, /** * JSON stringify and save a value to localStorage * @param {!string} key - key to set value for * @param {?Object} value - new value, if null remove item * @memberOf app.Storage */ set: function(key, value) { if (value !== null) { localStorage.setItem(key, JSON.stringify(value)); } else { localStorage.removeItem(key); } }, /** * Save a value to localStorage only if there is enough room * @param {!string} key - localStorage Key * @param {Object} value - value to save * @param {string} [keyBool] - key to a boolean value * that is true if the primary key has non-empty value * @returns {boolean} true if value was set successfully * @memberOf app.Storage */ safeSet: function(key, value, keyBool) { let ret = true; const oldValue = app.Storage.get(key); try { app.Storage.set(key, value); } catch (e) { ret = false; if (oldValue) { // revert to old value app.Storage.set(key, oldValue); } if (keyBool) { // revert to old value if (oldValue &amp;&amp; oldValue.length) { app.Storage.set(keyBool, true); } else { app.Storage.set(keyBool, false); } } // notify listeners const chromep = new ChromePromise(); chromep.runtime.sendMessage({ message: 'storageExceeded', }).catch((err) =&gt; {}); } return ret; }, }; })(); Ã— Search results Close "},"use500px.js.html":{"id":"use500px.js.html","title":"Source: use500px.js","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Source: use500px.js /* * Copyright (c) 2015-2017, Michael A. Updike All rights reserved. * Licensed under the BSD-3-Clause * https://opensource.org/licenses/BSD-3-Clause * https://github.com/opus1269/photo-screen-saver/blob/master/LICENSE.md */ window.app = window.app || {}; app.Use500px = (function() { 'use strict'; /** * Interface to 500px API * @namespace app.Use500px */ /** * 500px rest API * @type {string} * @const * @default * @private * @memberOf app.Use500px */ const _URL_BASE = 'https://api.500px.com/v1/'; /** * API authorization key * @type {string} * @const * @private * @memberOf app.Use500px */ const _KEY = 'iyKV6i6wu0R8QUea9mIXvEsQxIF0tMRVXopwYcFC'; /** * Max photos to return - 100 is API max * @type {int} * @const * @default * @private * @memberOf app.Use500px */ const _MAX_PHOTOS = 100; /** * Categories to use Make them an array to overcome 100 photo limit per call * @type {Array} * @const * @default * @private * @memberOf app.Use500px */ const _CATS = [ 'Nature,City and Architecture', 'Landscapes,Animals', 'Macro,Still Life,Underwater', ]; /** * Call API to get some photos * @param {string} url - server url * @returns {Promise&lt;Photo[]&gt;} Array of {@link Photo} objects * @private * @memberOf app.Use500px */ function _doGet(url) { return app.Http.doGet(url).then((response) =&gt; { if (response.error) { throw new Error(response.error); } const photos = []; for (let i = 0; i &lt; response.photos.length; i++) { const photo = response.photos[i]; if (!photo.nsfw) { const asp = photo.width / photo.height; app.Utils.addImage(photos, photo.images[0].url, photo.user.fullname, asp); } } return Promise.resolve(photos); }); } return { /** * Retrieve the array of 500px photos * @param {string} type - name of 500px gallery * @returns {Promise&lt;Photo[]&gt;} Array of {@link Photo} objects * @memberOf app.Use500px */ loadImages: function(type) { // series of API calls const promises = []; for (let i = 0; i &lt; _CATS.length; i++) { let url = `${_URL_BASE}photos/?consumer_key=${_KEY}&amp;feature=${type}` + `&amp;only=${_CATS[i]}&amp;rpp=${_MAX_PHOTOS}` + '&amp;sort=rating&amp;image_size=2048'; promises.push(_doGet(url)); } // Collate the photos return Promise.all(promises).then((values) =&gt; { let photos = []; values.forEach((value) =&gt; { photos = photos.concat(value); }); return Promise.resolve(photos); }); }, }; })(); Ã— Search results Close "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Source: utils.js /* * Copyright (c) 2015-2017, Michael A. Updike All rights reserved. * Licensed under the BSD-3-Clause * https://opensource.org/licenses/BSD-3-Clause * https://github.com/opus1269/photo-screen-saver/blob/master/LICENSE.md */ window.app = window.app || {}; app.Utils = (function() { 'use strict'; /** * Utility methods * @namespace app.Utils */ return { /** Get the extension's name * @returns {string} Extension name * @memberOf app.Utils */ getExtensionName: function() { return `chrome-extension://${chrome.runtime.id}`; }, /** * Get the Extension version * @returns {string} Extension version * @memberOf app.Utils */ getVersion: function() { const manifest = chrome.runtime.getManifest(); return manifest.version; }, /** * Get the Chrome version * @see http://stackoverflow.com/a/4900484/4468645 * @returns {int} Chrome major version * @memberOf app.Utils */ getChromeVersion: function() { const raw = navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./); return raw ? parseInt(raw[2], 10) : false; }, /** * Get the full Chrome version * @see https://goo.gl/2ITMNO * @returns {string} Chrome version * @memberOf app.Utils */ getFullChromeVersion: function() { const raw = navigator.userAgent; return raw ? raw : 'Unknown'; }, /** * Get the i18n string * @param {string} messageName - key in messages.json * @returns {string} internationalized string * @memberOf app.Utils */ localize: function(messageName) { return chrome.i18n.getMessage(messageName); }, /** * Determine if a String is null or whitespace only * @param {?string} str - string to check * @returns {boolean} true is str is whitespace (or null) * @memberOf app.Utils */ isWhiteSpace: function(str) { return (!str || str.length === 0 || /^\\s*$/.test(str)); }, /** * Get the idle time in seconds * @returns {int} idle time in seconds * @memberOf app.Utils */ getIdleSeconds: function() { const idle = app.Storage.get('idleTime'); return idle.base * 60; }, /** * true if we are MS windows * @returns {boolean} true if MS windows * @memberOf app.Utils */ isWin: function() { return app.Storage.get('os') === 'win'; }, /** * Returns a random integer between min and max inclusive * @param {int} min - min value * @param {int} max - max value * @returns {int} random int * @memberOf app.Utils */ getRandomInt: function(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }, /** * Randomly sort an Array in place * Fisher-Yates shuffle algorithm. * @param {Array} array - Array to sort * @memberOf app.Utils */ shuffleArray: function(array) { for (let i = array.length - 1; i &gt; 0; i--) { const j = Math.floor(Math.random() * (i + 1)); const temp = array[i]; array[i] = array[j]; array[j] = temp; } }, /** * Add an image object to an existing Array * @param {Array} images - Array of image objects * @param {string} url - The url to the photo * @param {string} author - The photographer * @param {number} asp - The aspect ratio of the photo * @param {Object} [ex] - Additional information about the photo * @memberOf app.Utils */ addImage: function(images, url, author, asp, ex) { const image = { url: url, author: author, asp: asp.toPrecision(3), }; if (ex) { image.ex = ex; } images.push(image); }, }; })(); Ã— Search results Close "},"photo.js.html":{"id":"photo.js.html","title":"Source: photo.js","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Source: photo.js /* * Copyright (c) 2015-2017, Michael A. Updike All rights reserved. * Licensed under the BSD-3-Clause * https://opensource.org/licenses/BSD-3-Clause * https://github.com/opus1269/photo-screen-saver/blob/master/LICENSE.md */ (function() { 'use strict'; /** * A photo for the screen saver * @param {string} name - unique name * @param {Object} source - source item * @constructor * @alias Photo */ const Photo = function(name, source) { this.name = name; this.path = source.url; this.author = source.author ? source.author : ''; this.type = source.type; this.aspectRatio = source.asp; this.ex = source.ex; this.width = screen.width; this.height = screen.height; this.label = this.buildLabel(false); }; /** * Create the photo label * @param {boolean} force - require display of label if true * @returns {string} label describing the photo source and photographer name */ Photo.prototype.buildLabel = function(force) { let ret = ''; let type = this.type; const idx = this.type.search('User'); if (!force &amp;&amp; !app.Storage.getBool('showPhotog') &amp;&amp; (idx !== -1)) { // don't show label for user's own photos, if requested return ret; } if (idx !== -1) { // strip off 'User' type = this.type.substring(0, idx - 1); } if (this.author) { ret = `${this.author} / ${type}`; } else { // no photographer name ret = `Photo from ${type}`; } return ret; }; /** * Determine if a photo would look bad zoomed or stretched on the screen * @param {number} asp aspect ratio of photo * @param {number} screenAsp - the screen aspect ratio * @returns {boolean} true if a photo aspect ratio differs substantially * from the screens' * @private */ Photo._isBadAspect = function(asp, screenAsp) { // arbitrary const CUT_OFF = 0.5; return (asp &lt; screenAsp - CUT_OFF) || (asp &gt; screenAsp + CUT_OFF); }; /** * Determine if a photo should not be displayed * @param {number} asp - aspect ratio * @param {number} screenAsp - the screen aspect ratio * @param {int} photoSizing - the sizing type * @returns {boolean} true if the photo should not be displayed */ Photo.ignore = function(asp, screenAsp, photoSizing) { let ret = false; const skip = app.Storage.getBool('skip'); if ((!asp || isNaN(asp)) || (skip &amp;&amp; ((photoSizing === 1) || (photoSizing === 3)) &amp;&amp; Photo._isBadAspect(asp, screenAsp))) { // ignore photos that don't have aspect ratio // or would look bad with cropped or stretched sizing options ret = true; } return ret; }; /** * Create a new tab with a link to the * original source of the current photo, if possible * @param {Object} item - a photo item */ Photo.showSource = function(item) { if (!item) { return; } const path = item.path; const extra = item.ex; let regex; let id; let url; switch (item.type) { case '500': // parse photo id regex = /(\\/[^\\/]*){4}/; id = path.match(regex); url = `http://500px.com/photo${id[1]}`; chrome.tabs.create({url: url}); break; case 'flickr': if (extra) { // parse photo id regex = /(\\/[^\\/]*){4}(_.*_)/; id = path.match(regex); url = `https://www.flickr.com/photos/${item.ex}${id[1]}`; chrome.tabs.create({url: url}); } break; case 'reddit': if (extra) { chrome.tabs.create({url: item.ex}); } break; default: break; } }; window.app = window.app || {}; app.Photo = Photo; })(window); Ã— Search results Close "},"photo_sources.js.html":{"id":"photo_sources.js.html","title":"Source: photo_sources.js","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Source: photo_sources.js /* * Copyright (c) 2015-2017, Michael A. Updike All rights reserved. * Licensed under the BSD-3-Clause * https://opensource.org/licenses/BSD-3-Clause * https://github.com/opus1269/photo-screen-saver/blob/master/LICENSE.md */ (function() { 'use strict'; /** * A potential source of photos for the screen saver * @param {string} useName - The key for the boolean value that indicates * if the source is selected * @param {string} photosName - The key for the collection of photos * @param {string} type - A descriptor of the photo source * @param {boolean} isDaily - Should the source be updated daily * @param {boolean} isArray - Is the source an Array of photo Arrays * @param {string} loadObj - the function wrapper for a photo source * as a string * @param {string} loadFn - function to call to retrieve the photo * collection as a string * @param {Array} loadArgs - Arguments to the loadFn * @constructor * @alias PhotoSource */ const PhotoSource = function(useName, photosName, type, isDaily, isArray, loadObj, loadFn, loadArgs) { this.useName = useName; this.photosName = photosName; this.type = type; this.isDaily = isDaily; this.isArray = isArray; this.loadObj = loadObj; this.loadFn = loadFn; this.loadArgs = loadArgs || []; }; /** * Determine if this source has been selected for display * @returns {boolean} true if selected */ PhotoSource.prototype.use = function() { return app.Storage.getBool(this.useName); }; /** * Process the photo source. * This normally requires a https call * and may fail for various reasons * Save to localStorage if there is enough room. * @returns {Promise&lt;void&gt;} void */ PhotoSource.prototype.process = function() { if (this.use()) { // convert string to function const fn = window.app[this.loadObj][this.loadFn]; let arg = null; if (this.loadArgs.length === 1) { arg = this.loadArgs[0]; } return fn(arg).then((photos) =&gt; { const err = this._savePhotos(photos); if (err) { throw new Error(err); } }); } else { if (this.useName !== 'useGoogle') { localStorage.removeItem(this.photosName); } return Promise.resolve(); } }; /** * Save the photos to localStorage in a safe manner * @param {Array} photos - an array of photo objects * @returns {?string} non-null on error * @private */ PhotoSource.prototype._savePhotos = function(photos) { let ret = null; const keyBool = (this.useName === 'useGoogle') ? null : this.useName; if (photos || photos.length) { const set = app.Storage.safeSet(this.photosName, photos, keyBool); if (!set) { ret = 'Exceeded storage capacity.'; } } return ret; }; /** * Add the type specifier (source of the photo) for each * photo object in the array * @param {Array} arr - an array of photo objects * @private */ PhotoSource.prototype._addType = function(arr) { for (let i = 0; i &lt; arr.length; i++) { arr[i].type = this.type; } }; /** * Get all the photos from local storage * @returns {Array} The Array of photos * @private */ PhotoSource.prototype._getPhotos = function() { let ret = []; if (this.use()) { if (this.isArray) { const items = app.Storage.get(this.photosName); if (items) { // could be that items have not been retrieved yet for (let i = 0; i &lt; items.length; i++) { ret = ret.concat(items[i].photos); if (ret) { this._addType(ret); } } } } else { ret = app.Storage.get(this.photosName); if (ret) { this._addType(ret); } else { ret = []; } } } return ret; }; /** * Array of PhotoSources * @type {Array} */ PhotoSource.SOURCES = [ new PhotoSource('useGoogle', 'albumSelections', 'Google User', true, true, 'GooglePhotos', 'loadImages', []), new PhotoSource('useChromecast', 'ccImages', 'Google', false, false, 'ChromeCast', 'loadImages', []), new PhotoSource('useEditors500px', 'editors500pxImages', '500', true, false, 'Use500px', 'loadImages', ['editors']), new PhotoSource('usePopular500px', 'popular500pxImages', '500', true, false, 'Use500px', 'loadImages', ['popular']), new PhotoSource('useYesterday500px', 'yesterday500pxImages', '500', true, false, 'Use500px', 'loadImages', ['fresh_yesterday']), new PhotoSource('useSpaceReddit', 'spaceRedditImages', 'reddit', true, false, 'Reddit', 'loadImages', ['r/spaceporn/']), new PhotoSource('useEarthReddit', 'earthRedditImages', 'reddit', true, false, 'Reddit', 'loadImages', ['r/EarthPorn/']), new PhotoSource('useAnimalReddit', 'animalRedditImages', 'reddit', true, false, 'Reddit', 'loadImages', ['r/animalporn/']), new PhotoSource('useInterestingFlickr', 'flickrInterestingImages', 'flickr', true, false, 'Flickr', 'loadImages', []), new PhotoSource('useAuthors', 'authorImages', 'Google', false, false, 'GooglePhotos', 'loadAuthorImages', []), ]; /** * Get all the keys of useage boolean variables * @returns {Array} Array of keys of useage boolean variables */ PhotoSource.getUseNames = function() { let ret = []; for (let i = 0; i &lt; PhotoSource.SOURCES.length; i++) { ret = ret.concat(PhotoSource.SOURCES[i].useName); } return ret; }; /** * Get all the photos from all selected sources. These will be * used by the screensaver. * @returns {Array} Array of photos to display in screen saver */ PhotoSource.getSelectedPhotos = function() { let ret = []; for (let i = 0; i &lt; PhotoSource.SOURCES.length; i++) { ret = ret.concat(PhotoSource.SOURCES[i]._getPhotos()); } return ret; }; /** * Determine if a given string is a photo source * @param {string} useName - String to check * @returns {boolean} true if photo source */ PhotoSource.contains = function(useName) { for (let i = 0; i &lt; PhotoSource.SOURCES.length; i++) { if (PhotoSource.SOURCES[i].useName === useName) { return true; } } return false; }; /** * Process the given photo source and save to localStorage. * This normally requires a https call * and may fail for various reasons * @param {string} useName - The photo source to retrieve * @returns {Promise&lt;void&gt;} void */ PhotoSource.process = function(useName) { for (let i = 0; i &lt; PhotoSource.SOURCES.length; i++) { if (PhotoSource.SOURCES[i].useName === useName) { return PhotoSource.SOURCES[i].process(); } } // not found, shouldn't be here return Promise.resolve(); }; /** * Process all the selected photo sources and save to localStorage. * This normally requires a https call * and may fail for various reasons */ PhotoSource.processAll = function() { for (let i = 0; i &lt; PhotoSource.SOURCES.length; i++) { PhotoSource.SOURCES[i].process(); } }; /** * Process all the selected photo sources that are to be * updated every day and save to localStorage. * This normally requires a https call * and may fail for various reasons */ PhotoSource.processDaily = function() { for (let i = 0; i &lt; PhotoSource.SOURCES.length; i++) { if (PhotoSource.SOURCES[i].isDaily) { PhotoSource.SOURCES[i].process(); } } }; window.app = window.app || {}; app.PhotoSource = PhotoSource; })(window); Ã— Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Global Type Definitions AppData Values for items in localStorage Type: Object Properties: Name Type Description version int version of data enabled boolean is screensaver enabled idleTime UnitValue idle time to display screensaver transitionTime UnitValue time between photos skip boolean ignore extreme aspect ratio photos shuffle boolean randomize photo order photoSizing int photo display type photoTransition int transition animation showTime int time display format showPhotog boolean display name on own photos background string background image keepAwake boolean manage computer poser settings chromeFullscreen boolean don't display over fullscreen Chrome windows allDisplays boolean show on all displays activeStart string Keep Wake start time '00:00' 24 hr activeStop string Keep Wake stop time '00:00' 24 hr allowSuspend boolean let computer sleep useSpaceReddit boolean use this photo source useEarthReddit boolean use this photo source useAnimalReddit boolean use this photo source useEditors500px boolean use this photo source usePopular500px boolean use this photo source useYesterday500px boolean use this photo source useInterestingFlickr boolean use this photo source useChromecast boolean use this photo source useAuthors boolean use this photo source useGoogle boolean use this photo source useSpaceReddit boolean use this photo source albumSelections Array Users Google Photos to use Source: data.js, line 36 UnitValue A number and associated units Type: Object Properties: Name Type Description base number value in base unit display number value in display unit unit int display unit Source: data.js, line 28 Ã— Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Classes Classes Photo PhotoSource Namespaces Alarm Background ChromeCast Data Flickr GooglePhotos Http Options PhotoView Reddit ScreenSaver SSControl Storage Use500px Utils Ã— Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Namespaces Classes Photo PhotoSource Namespaces Alarm Background ChromeCast Data Flickr GooglePhotos Http Options PhotoView Reddit ScreenSaver SSControl Storage Use500px Utils Ã— Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Photo Screen Saver Chrome ExtensionThis extension displays a screensaver composed of a slide show of photos from multiple sources. Supported photo sources include: Your Google Photos - Note: Shared Albums are not supported Some background photos used by Chromecast Several streams from 500px Several sources from reddit Interesting photos from Flickr Note: Photos from the local file system are not supported. Many options are available to control the appearance of the slide show, including: Wait time after machine becomes idle to display screensaver Between photo time interval Photo display mode - (e.g., letterbox, fill screen) Photo transition animations - (e.g., fade, scale up) A scheduler to control when the screensaver, display, and computer should remain on Do not display over full screen Chrome windows (e.g., YouTube, Netflix) Show on all displays Display time Works great on all platforms but may be especially useful for your Chromebook. It is free and advertising free. It is implemented using Vanilla JavaScript and Polymer 1. View in Chrome Web Store GitHub Pages Ã— Search results Close "},"app.Alarm.html":{"id":"app.Alarm.html","title":"Namespace: Alarm","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Namespace: Alarm Alarm Manage alarms from the chrome.alarms API Source: alarm.js, line 11 See: https://developer.chrome.com/apps/alarms Members &lt;private, static, constant&gt; Alarms :Object Alarms triggered by chrome.alarms Type: Object Properties: Name Type Description ACTIVATE string screen saver is active DEACTIVATE string screen saver is not activate UPDATE_PHOTOS string photo sources should be updated BADGE_TEXT string icon's Badge text should be set Source: alarm.js, line 19 &lt;private, static, constant&gt; Time :Object Time constants Type: Object Properties: Name Type Description MIN_IN_DAY int minutes in a day MSEC_IN_DAY int milliSeconds in a day Source: alarm.js, line 37 Methods &lt;private, static&gt; _getTime(value) â†’ {int} Convert string to time Parameters: Name Type Description value string format: 'hh:mm' 24 hour time Source: alarm.js, line 58 Returns: time in mSec from epoch Type int &lt;private, static&gt; _getTimeDelta(value) â†’ {int} Calculate time delta from now on a 24 hr basis Parameters: Name Type Description value string format: 'hh:mm' 24 hour time Source: alarm.js, line 75 Returns: time delta in minutes Type int &lt;private, static&gt; _isInRange(start, stop) â†’ {boolean} Determine if current time is between start and stop, inclusive Parameters: Name Type Description start string format: 'hh:mm' 24 hour time stop string format: 'hh:mm' 24 hour time Source: alarm.js, line 94 Returns: true if in the given range Type boolean &lt;private, static&gt; _onAlarm(alarm) Event: Fired when an alarm has elapsed. Parameters: Name Type Description alarm Object details on alarm Source: alarm.js, line 173 See: https://developer.chrome.com/apps/alarms#event-onAlarm &lt;private, static&gt; _setActiveState() Set state when the screensaver is in the active time range Source: alarm.js, line 119 &lt;private, static&gt; _setBadgeText() Set the Badge text on the icon Source: alarm.js, line 153 &lt;private, static&gt; _setInactiveState() Set state when the screensaver is in the inactive time range Source: alarm.js, line 138 &lt;static&gt; isActive() â†’ {boolean} Determine if the screen saver can be displayed Source: alarm.js, line 260 Returns: true if can display Type boolean &lt;static&gt; updateBadgeText() Set the icon badge text Source: alarm.js, line 248 &lt;static&gt; updateRepeatingAlarms() Set the repeating alarms states Source: alarm.js, line 204 Ã— Search results Close "},"app.Background.html":{"id":"app.Background.html","title":"Namespace: Background","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Namespace: Background Background The background script for the extension. Source: background.js, line 10 Methods &lt;private, static&gt; _onChromeMessage(request, sender, response) â†’ {boolean} Event: Fired when a message is sent from either an extension process (by runtime.sendMessage) or a content script (by tabs.sendMessage). Parameters: Name Type Description request Object details for the message Properties Name Type Description message string name of the message sender Object MessageSender object response function function _to call once after processing Source: background.js, line 150 See: https://developer.chrome.com/extensions/runtime#event-onMessage Returns: true if asynchronous Type boolean &lt;private, static&gt; _onIconClicked() Event: Fired when a browser action icon is clicked. Source: background.js, line 93 See: https://goo.gl/abVwKu &lt;private, static&gt; _onInstalled(details) Event: Fired when the extension is first installed, when the extension is updated to a new version, and when Chrome is updated to a new version. Parameters: Name Type Description details Object type of event Source: background.js, line 52 See: https://developer.chrome.com/extensions/runtime#event-onInstalled &lt;private, static&gt; _onKeyCommand(cmd) Event: Fired when a registered command is activated using a keyboard shortcut. Parameters: Name Type Description cmd string keyboard command Source: background.js, line 131 See: https://developer.chrome.com/extensions/commands#event-onCommand &lt;private, static&gt; _onMenuClicked(info) Event: Fired when a context menu item is clicked. Parameters: Name Type Description info Object info. on the clicked menu Properties Name Type Description menuItemId Object menu name Source: background.js, line 117 See: https://developer.chrome.com/extensions/contextMenus#event-onClicked &lt;private, static&gt; _onStartup() Event: Fired when a profile that has this extension installed first starts up Source: background.js, line 83 See: https://developer.chrome.com/extensions/runtime#event-onStartup &lt;private, static&gt; _onStorageChanged(event) Event: Fired when item in localStorage changes Parameters: Name Type Description event Event StorageEvent Properties Name Type Description key string storage item that changed Source: background.js, line 105 See: https://developer.mozilla.org/en-US/docs/Web/Events/storage &lt;private, static&gt; _showOptionsTab() Display the options tab Source: background.js, line 22 &lt;private, static&gt; _toggleEnabled() Toggle enabled state of the screen saver Source: background.js, line 37 Ã— Search results Close "},"app.ChromeCast.html":{"id":"app.ChromeCast.html","title":"Namespace: ChromeCast","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Namespace: ChromeCast ChromeCast Interface to the Chromecast photos Source: chromecast.js, line 11 Methods &lt;static&gt; loadImages() â†’ {Promise.&lt;Array.&lt;Photo&gt;&gt;} Get the photos from chromecast.json Source: chromecast.js, line 22 Returns: Array of Photo objects Type Promise.&lt;Array.&lt;Photo&gt;&gt; Ã— Search results Close "},"app.Data.html":{"id":"app.Data.html","title":"Namespace: Data","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Namespace: Data Data Manage the extensions data Source: data.js, line 11 Members &lt;private, static, constant&gt; _DATA_VERSION :int Version of localStorage - update when items are added, removed, changed Type: int Default Value: 10 Source: data.js, line 26 &lt;private, static, constant&gt; _DEF_VALUES :AppData Default values in localStorage Type: AppData Source: data.js, line 78 Methods &lt;private, static&gt; _addDefaults() Save the _DEF_VALUES items, if they do not already exist Source: data.js, line 183 &lt;private, static&gt; _convertSliderValue(key) Convert a setting-slider value due to addition of units Parameters: Name Type Description key string localStorage key Source: data.js, line 197 &lt;private, static&gt; _getTimeFormat() â†’ {int} Get default time format based on locale Source: data.js, line 155 Returns: 12 or 24 Type int &lt;private, static&gt; _processEnabled() Set state based on screensaver enabled flag Note: this does not effect the keep awake settings so you could use the extension as a display keep awake scheduler without using the screensaver Source: data.js, line 117 &lt;private, static&gt; _processIdleTime() Set wait time for screen saver display after machine is idle Source: data.js, line 145 &lt;private, static&gt; _processKeepAwake() Set power scheduling features Source: data.js, line 132 &lt;private, static&gt; _setOS() â†’ {Promise} Set the 'os' value Source: data.js, line 170 Returns: err on failure Type Promise &lt;static&gt; initialize() Initialize the data saved in localStorage Source: data.js, line 214 &lt;static&gt; processState( [key]) Process changes to localStorage items Parameters: Name Type Argument Default Description key string &lt;optional&gt; 'all' the item that changed Source: data.js, line 286 &lt;static&gt; restoreDefaults() Restore default values for data saved in localStorage Source: data.js, line 265 &lt;static&gt; update() Update the data saved in localStorage Source: data.js, line 231 Ã— Search results Close "},"app.Flickr.html":{"id":"app.Flickr.html","title":"Namespace: Flickr","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Namespace: Flickr Flickr Interface to flickr API Source: flickr.js, line 11 Members &lt;private, static, constant&gt; _KEY :string Flickr rest API authorization key Type: string Source: flickr.js, line 33 &lt;private, static, constant&gt; _MAX_PHOTOS :int Max photos to return Type: int Default Value: 300 Source: flickr.js, line 43 &lt;private, static, constant&gt; _URL_BASE :string Flickr rest API Type: string Default Value: https://api.flickr.com/services/rest/ Source: flickr.js, line 24 Methods &lt;static&gt; loadImages() â†’ {Promise.&lt;Array.&lt;Photo&gt;&gt;} Retrieve flickr photos Source: flickr.js, line 51 Returns: Array of Photo objects Type Promise.&lt;Array.&lt;Photo&gt;&gt; Ã— Search results Close "},"app.GooglePhotos.html":{"id":"app.GooglePhotos.html","title":"Namespace: GooglePhotos","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Namespace: GooglePhotos GooglePhotos Interface to Picasa API Source: google_photos.js, line 11 Members &lt;private, static, constant&gt; _ALBUM_QUERY :string Query an album Type: string Source: google_photos.js, line 34 &lt;private, static, constant&gt; _URL_BASE :string Path to Picasa API Type: string Default Value: https://picasaweb.google.com/data/feed/api/user/ Source: google_photos.js, line 24 Methods &lt;private, static&gt; _isImage(entry) â†’ {boolean} Determine if a Picasa entry is an image Parameters: Name Type Description entry Object Picasa media object Source: google_photos.js, line 44 Returns: true if entry is a photo Type boolean &lt;private, static&gt; _loadPicasaAlbum(albumId [, userId]) â†’ {Promise.&lt;Object&gt;} Retrieve a Google Photos album Parameters: Name Type Argument Default Description albumId string Picasa album ID userId string &lt;optional&gt; 'default' userId for non-authenticated request Source: google_photos.js, line 88 Returns: Root object from Picasa call Type Promise.&lt;Object&gt; &lt;private, static&gt; _processPhotos(root) â†’ {Array} Extract the Picasa photos into an Array Parameters: Name Type Description root Object root object from Picasa API call Source: google_photos.js, line 61 Returns: Array of photo objects Type Array &lt;static&gt; loadAlbumList() â†’ {Promise.&lt;Array&gt;} Retrieve the users list of albums, including the photos in each Source: google_photos.js, line 122 Returns: Array of Arrays Type Promise.&lt;Array&gt; &lt;static&gt; loadAuthorImages() â†’ {Promise.&lt;Array.&lt;Photo&gt;&gt;} Get my photo album Source: google_photos.js, line 105 Returns: Array of Photo objects Type Promise.&lt;Array.&lt;Photo&gt;&gt; &lt;static&gt; loadImages() â†’ {Promise.&lt;Array&gt;} Retrieve the photos in the selected albums Array of Array of album photos on success Source: google_photos.js, line 180 Returns: Array of Array of albums Type Promise.&lt;Array&gt; Ã— Search results Close "},"app.Http.html":{"id":"app.Http.html","title":"Namespace: Http","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Namespace: Http Http Fetch with authentication and exponential backoff Source: http.js, line 11 Members &lt;private, static, constant&gt; _DELAY Delay multiplier for exponential back-off Default Value: 1000 Source: http.js, line 34 &lt;private, static, constant&gt; _MAX_RETRIES Max retries on 500 errors Default Value: 4 Source: http.js, line 25 Methods &lt;private, static&gt; _doAuth(isAuth, interactive) â†’ {Promise.&lt;string&gt;} Get auth token if requested Parameters: Name Type Description isAuth boolean true if authorization required interactive boolean true if auth call is interactive Source: http.js, line 60 Returns: auth token if needed Type Promise.&lt;string&gt; &lt;static&gt; _doGet() â†’ {Promise.&lt;json&gt;} Fetch with exponential back-off Source: http.js, line 87 Returns: response from server Type Promise.&lt;json&gt; &lt;private, static&gt; _retryGet(url, authToken) â†’ {Promise.&lt;void&gt;} Retry call to server after removing cached auth token Parameters: Name Type Description url string url to call authToken string chrome authorization token Source: http.js, line 44 Returns: response from server Type Promise.&lt;void&gt; &lt;static&gt; doGet(url [, isAuth] [, retryAuth]) â†’ {Promise.&lt;json&gt;} Perform GET request to server using exponential back-off Parameters: Name Type Argument Default Description url string server isAuth boolean &lt;optional&gt; false true if authorization required retryAuth boolean &lt;optional&gt; false if true, retry with new token Source: http.js, line 77 Returns: response from server Type Promise.&lt;json&gt; Ã— Search results Close "},"app.Options.html":{"id":"app.Options.html","title":"Namespace: Options","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Namespace: Options Options Extension's Options page Source: options.js, line 10 Members &lt;private, static, constant&gt; EXT_URI :string Path to the extension in the Web Store Type: string Source: options.js, line 37 &lt;private, static, constant&gt; PUSHY_URI :string Path to my Pushy Clipboard extension Type: string Source: options.js, line 49 &lt;private, static, constant&gt; t :Object auto-binding template Type: Object Source: options.js, line 60 &lt;static&gt; t.pages :Array.&lt;app.Options.Page&gt; Array of pages Type: Array.&lt;app.Options.Page&gt; Source: options.js, line 202 Methods &lt;private, static&gt; _showHelpPage(index) Show the help page Parameters: Name Type Description index int index into t.pages Source: options.js, line 156 &lt;static&gt; t.closeDrawer() Close drawer if drawerPanel is narrow Source: options.js, line 251 &lt;static&gt; t.computeMenu() â†’ {string} Computed property: Menu label Source: options.js, line 86 Returns: i18n label Type string &lt;static&gt; t.computeTitle() â†’ {string} Computed property: Page title Source: options.js, line 77 Returns: i18n title Type string &lt;static&gt; t.googlePhotos(index) Show the Google Photos page Parameters: Name Type Description index int index into t.pages Source: options.js, line 135 &lt;static&gt; t.help(index) Show the Help page Parameters: Name Type Description index int index into t.pages Source: options.js, line 172 &lt;static&gt; t.onDataRouteClick(event) Event Listener for main menu clicks Route to proper page Parameters: Name Type Description event Event ClickEvent Source: options.js, line 106 &lt;private, static&gt; t.onMessage(request, sender, response) â†’ {boolean} Event: Fired when a message is sent from either an extension process (by runtime.sendMessage) or a content script (by tabs.sendMessage). Parameters: Name Type Description request Object details for the message Properties Name Type Description message string name of the message sender Object MessageSender object response function function to call once after processing Source: options.js, line 270 See: https://developer.chrome.com/extensions/runtime#event-onMessage Returns: true if asynchronous Type boolean &lt;static&gt; t.preview() Display a preview of the screen saver Source: options.js, line 187 &lt;static&gt; t.scrollPageToTop() Scroll page to top Source: options.js, line 243 Type Definitions Page Manage an html page that is inserted on demand May also be a url link to external site Type: Object Properties: Name Type Argument Description label string label for Nav menu route string element name route to page icon string icon for Nav Menu obj Object &lt;nullable&gt; something to be done when selected ready boolean true if html is inserted divider boolean true for divider before item Source: options.js, line 17 Ã— Search results Close "},"app.PhotoView.html":{"id":"app.PhotoView.html","title":"Namespace: PhotoView","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Namespace: PhotoView PhotoView Handle rendering of a photo in screen saver Source: photo_view.js, line 11 Members &lt;private, static, constant&gt; SCREEN_ASPECT :number Aspect ratio of screen Type: number Source: photo_view.js, line 34 Methods &lt;private, static&gt; _frame(idx) Finalize DOM for a framed photo Parameters: Name Type Description idx int index into animated pages Source: photo_view.js, line 103 &lt;private, static&gt; _getElements(idx) â†’ {Elements} Get references to the important elements of a slide Parameters: Name Type Description idx int index into animated pages Source: photo_view.js, line 43 Returns: Object containing the elements of a slide Type Elements &lt;private, static&gt; _letterbox(idx) Finalize DOM for a letter boxed photo Parameters: Name Type Description idx int index into animated pages Source: photo_view.js, line 62 &lt;private, static&gt; _stretch(idx) Finalize DOM for a stretched photo Parameters: Name Type Description idx int index into animated pages Source: photo_view.js, line 89 &lt;private, static&gt; _super500px(idx) Add superscript to the label for 500px photos Parameters: Name Type Description idx int index into animated pages Source: photo_view.js, line 181 &lt;static&gt; getName(idx) â†’ {string} Get the name of the photo in this view Parameters: Name Type Description idx int index into animated pages Source: photo_view.js, line 195 Returns: name of photo Type string &lt;static&gt; isError(idx) â†’ {boolean} Determine if a photo failed to load (usually 404 error) Parameters: Name Type Description idx int index into animated pages Source: photo_view.js, line 230 Returns: true if image load failed Type boolean &lt;static&gt; isLoaded(idx) â†’ {boolean} Determine if a photo has finished loading Parameters: Name Type Description idx int index into animated pages Source: photo_view.js, line 241 Returns: true if image is loaded Type boolean &lt;static&gt; prep(idx, t) Finalize DOM for a photo Parameters: Name Type Description idx int index into animated pages t Object Polymer template Source: photo_view.js, line 206 &lt;static&gt; setTime(t) Build and set the time string Parameters: Name Type Description t Object Polymer template Source: photo_view.js, line 251 Type Definitions Elements Important components of a photo view Type: Object Properties: Name Type Description image Element paper-image author Element label time Element label model Object template model item Object photo item Source: photo_view.js, line 16 Ã— Search results Close "},"app.Reddit.html":{"id":"app.Reddit.html","title":"Namespace: Reddit","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Namespace: Reddit Reddit Interface to Reddit API Source: reddit.js, line 11 Members &lt;private, static, constant&gt; _KEY :string Reddit rest API authorization key Type: string Source: reddit.js, line 33 &lt;private, static, constant&gt; _MAX_PHOTOS :int Max photos to return Type: int Default Value: 100 Source: reddit.js, line 43 &lt;private, static, constant&gt; _MAX_SIZE :int Max size of photo to use Type: int Default Value: 3500 Source: reddit.js, line 63 &lt;private, static, constant&gt; _MIN_SIZE :int Min size of photo to use Type: int Default Value: 750 Source: reddit.js, line 53 &lt;private, static, constant&gt; _REDIRECT_URI :string Extension's redirect uri Type: string Source: reddit.js, line 23 &lt;private, static, constant&gt; _snoocore :function Expose reddit API Type: function Source: reddit.js, line 72 Methods &lt;private, static&gt; _getSize(title) â†’ {Object} Parse the size from the submission title. this is the old way reddit did it Parameters: Name Type Description title string submission title Source: reddit.js, line 91 Returns: Photo size Type Object &lt;private, static&gt; _processChildren(children) â†’ {Array} Build the list of photos for one page of items Parameters: Name Type Description children Array Array of photos returned from reddit Source: reddit.js, line 110 Returns: Array of Photo objects, stripped of NSFW and big and small photos Type Array &lt;static&gt; loadImages(subreddit) â†’ {Promise.&lt;Array.&lt;Photo&gt;&gt;} Retrieve the array of reddit photos Parameters: Name Type Description subreddit string name of photo subreddit Source: reddit.js, line 158 Returns: Array of Photo objects Type Promise.&lt;Array.&lt;Photo&gt;&gt; Ã— Search results Close "},"app.ScreenSaver.html":{"id":"app.ScreenSaver.html","title":"Namespace: ScreenSaver","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Namespace: ScreenSaver ScreenSaver Display a screen saver Source: screensaver.js, line 14 Members &lt;private, static, constant&gt; CLOCK_ALARM :string repeating alarm for updating time label Type: string Default Value: updateTimeLabel Source: screensaver.js, line 48 &lt;private, static, constant&gt; MAX_PAGES :int max number of animated pages Type: int Default Value: 20 Source: screensaver.js, line 38 &lt;private, static, constant&gt; SCREEN_ASPECT :number aspect ratio of screen Type: number Source: screensaver.js, line 28 &lt;private, static, constant&gt; t :Object main auto-bind template Type: Object Source: screensaver.js, line 61 &lt;static&gt; t.curIdx :int Index into t.itemsAll Type: int Source: screensaver.js, line 81 &lt;static&gt; t.items :Array Array of photos MAX_PAGES long, currently loaded into the neon-animated-pages. Always changing subset of t.itemsAll Type: Array Source: screensaver.js, line 90 &lt;static&gt; t.itemsAll :Array array of all the photos to use for slide show Type: Array Source: screensaver.js, line 74 Methods &lt;static&gt; t.closeWindow() Close ourselves Source: screensaver.js, line 447 &lt;static&gt; t.findLoadedPhoto(idx) â†’ {int} Try to find a photo that has finished loading Parameters: Name Type Description idx int index into t.items Source: screensaver.js, line 252 Returns: index into t.items of a loaded photo, -1 if none are loaded Type int &lt;static&gt; t.getNextPhoto(idx) â†’ {int} Get the next photo to display Parameters: Name Type Description idx int index into t.items Source: screensaver.js, line 344 Returns: next - index into t.items to display, -1 if none are ready Type int &lt;static&gt; t.loadImages() Build the Array of photos that will be displayed and populate the neon-animated-pages Source: screensaver.js, line 214 &lt;static&gt; t.onAlarm(alarm) Listen for alarms Parameters: Name Type Description alarm Object chrome alarm Properties Name Type Description name string alarm type Source: screensaver.js, line 434 &lt;static&gt; t.onMessage(request, sender, response) â†’ {boolean} Event: Fired when a message is sent from either an extension process (by runtime.sendMessage) or a content script (by tabs.sendMessage). Parameters: Name Type Description request Object details for the message sender Object MessageSender object response function function to call once after processing Source: screensaver.js, line 418 See: https://developer.chrome.com/extensions/runtime#event-onMessage Returns: true if asynchronous Type boolean &lt;static&gt; t.processPhotoSizing() Process settings related to photo appearance Source: screensaver.js, line 187 &lt;static&gt; t.processPhotoTransitions() Process settings related to between photo transition Source: screensaver.js, line 152 &lt;static&gt; t.processZoom() Process Chrome window Zoom factor Source: screensaver.js, line 137 &lt;static&gt; t.replaceAllPhotos() Replace the active photos with new photos from the master array Source: screensaver.js, line 312 &lt;static&gt; t.replacePhoto(idx, error) Add the next photo from the master array Parameters: Name Type Description idx int index into t.items error boolean true if the photo at idx didn't load Source: screensaver.js, line 279 &lt;static&gt; t.runShow() Called at fixed time intervals to cycle through the photos Runs forever Source: screensaver.js, line 371 Ã— Search results Close "},"app.SSControl.html":{"id":"app.SSControl.html","title":"Namespace: SSControl","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Namespace: SSControl SSControl Controller for the screen saver Source: ss_controller.js, line 11 Members &lt;private, static, constant&gt; _SS_URL :string Screensaver URL Type: string Default Value: /html/screensaver.html Source: ss_controller.js, line 26 Methods &lt;private, static&gt; _hasFullscreen(display) â†’ {Promise.&lt;boolean&gt;} Determine if there is a full screen chrome window running on a display Parameters: Name Type Description display Object a connected display Source: ss_controller.js, line 36 Returns: true if there is a full screen window on the display Type Promise.&lt;boolean&gt; &lt;private, static&gt; _isShowing() â†’ {Promise.&lt;boolean&gt;} Determine if the screen saver is currently showing Source: ss_controller.js, line 63 Returns: true if showing Type Promise.&lt;boolean&gt; &lt;private, static&gt; _onChromeMessage(request, sender, response) â†’ {boolean} Event: Fired when a message is sent from either an extension process (by runtime.sendMessage) or a content script (by tabs.sendMessage). Parameters: Name Type Description request Object details for the message Properties Name Type Description message string name of the message sender Object MessageSender object response function function to call once after processing Source: ss_controller.js, line 171 See: https://developer.chrome.com/extensions/runtime#event-onMessage Returns: true if asynchronous Type boolean &lt;private, static&gt; _onIdleStateChanged(state) Event: Fired when the system changes to an active, idle or locked state. The event fires with &quot;locked&quot; if the screen is locked or the screensaver activates, &quot;idle&quot; if the system is unlocked and the user has not generated any input for a specified number of seconds, and &quot;active&quot; when the user generates input on an idle system. Parameters: Name Type Description state string current state of computer Source: ss_controller.js, line 143 See: https://developer.chrome.com/extensions/idle#event-onStateChanged &lt;private, static&gt; _open(display) Open a screen saver window on the given display Parameters: Name Type Description display Object a connected display Source: ss_controller.js, line 82 &lt;private, static&gt; _openOnAllDisplays() Open a screensaver on every display Source: ss_controller.js, line 120 &lt;static&gt; close() Close all the screen saver windows Source: ss_controller.js, line 204 &lt;static&gt; display(single) Display the screen saver(s) !Important: Always request screensaver through this call Parameters: Name Type Description single boolean if true only show on one display Source: ss_controller.js, line 192 Ã— Search results Close "},"app.Storage.html":{"id":"app.Storage.html","title":"Namespace: Storage","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Namespace: Storage Storage Manage items in localStorage Source: storage.js, line 11 Methods &lt;static&gt; get(key) â†’ {JSON} Get a JSON parsed value from localStorage Parameters: Name Type Description key string key to get value for Source: storage.js, line 23 Returns: JSON object, null if key does not exist Type JSON &lt;static&gt; getBool(key) â†’ {boolean} Get boolean value from localStorage Parameters: Name Type Description key string key to get value for Source: storage.js, line 51 Returns: value as boolean Type boolean &lt;static&gt; getInt(key) â†’ {int} Get integer value from localStorage Parameters: Name Type Description key string key to get value for Source: storage.js, line 37 Returns: value as integer Type int &lt;static&gt; safeSet(key, value [, keyBool]) â†’ {boolean} Save a value to localStorage only if there is enough room Parameters: Name Type Argument Description key string localStorage Key value Object value to save keyBool string &lt;optional&gt; key to a boolean value that is true if the primary key has non-empty value Source: storage.js, line 78 Returns: true if value was set successfully Type boolean &lt;static&gt; set(key, value) JSON stringify and save a value to localStorage Parameters: Name Type Argument Description key string key to set value for value Object &lt;nullable&gt; new value, if null remove item Source: storage.js, line 61 Ã— Search results Close "},"app.Use500px.html":{"id":"app.Use500px.html","title":"Namespace: Use500px","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Namespace: Use500px Use500px Interface to 500px API Source: use500px.js, line 11 Members &lt;private, static, constant&gt; _CATS :Array Categories to use Make them an array to overcome 100 photo limit per call Type: Array Default Value: [&quot;Nature,City and Architecture&quot;,&quot;Landscapes,Animals&quot;,&quot;Macro,Still Life,Underwater&quot;] Source: use500px.js, line 53 &lt;private, static, constant&gt; _KEY :string API authorization key Type: string Source: use500px.js, line 33 &lt;private, static, constant&gt; _MAX_PHOTOS :int Max photos to return - 100 is API max Type: int Default Value: 100 Source: use500px.js, line 43 &lt;private, static, constant&gt; _URL_BASE :string 500px rest API Type: string Default Value: https://api.500px.com/v1/ Source: use500px.js, line 24 Methods &lt;private, static&gt; _doGet(url) â†’ {Promise.&lt;Array.&lt;Photo&gt;&gt;} Call API to get some photos Parameters: Name Type Description url string server url Source: use500px.js, line 66 Returns: Array of Photo objects Type Promise.&lt;Array.&lt;Photo&gt;&gt; &lt;static&gt; loadImages(type) â†’ {Promise.&lt;Array.&lt;Photo&gt;&gt;} Retrieve the array of 500px photos Parameters: Name Type Description type string name of 500px gallery Source: use500px.js, line 91 Returns: Array of Photo objects Type Promise.&lt;Array.&lt;Photo&gt;&gt; Ã— Search results Close "},"app.Utils.html":{"id":"app.Utils.html","title":"Namespace: Utils","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Namespace: Utils Utils Utility methods Source: utils.js, line 11 Methods &lt;static&gt; addImage(images, url, author, asp [, ex]) Add an image object to an existing Array Parameters: Name Type Argument Description images Array Array of image objects url string The url to the photo author string The photographer asp number The aspect ratio of the photo ex Object &lt;optional&gt; Additional information about the photo Source: utils.js, line 131 &lt;static&gt; getChromeVersion() â†’ {int} Get the Chrome version Source: utils.js, line 41 See: http://stackoverflow.com/a/4900484/4468645 Returns: Chrome major version Type int &lt;static&gt; getExtensionName() â†’ {string} Get the extension's name Source: utils.js, line 21 Returns: Extension name Type string &lt;static&gt; getFullChromeVersion() â†’ {string} Get the full Chrome version Source: utils.js, line 52 See: https://goo.gl/2ITMNO Returns: Chrome version Type string &lt;static&gt; getIdleSeconds() â†’ {int} Get the idle time in seconds Source: utils.js, line 82 Returns: idle time in seconds Type int &lt;static&gt; getRandomInt(min, max) â†’ {int} Returns a random integer between min and max inclusive Parameters: Name Type Description min int min value max int max value Source: utils.js, line 103 Returns: random int Type int &lt;static&gt; getVersion() â†’ {string} Get the Extension version Source: utils.js, line 30 Returns: Extension version Type string &lt;static&gt; isWhiteSpace(str) â†’ {boolean} Determine if a String is null or whitespace only Parameters: Name Type Argument Description str string &lt;nullable&gt; string to check Source: utils.js, line 73 Returns: true is str is whitespace (or null) Type boolean &lt;static&gt; isWin() â†’ {boolean} true if we are MS windows Source: utils.js, line 92 Returns: true if MS windows Type boolean &lt;static&gt; localize(messageName) â†’ {string} Get the i18n string Parameters: Name Type Description messageName string key in messages.json Source: utils.js, line 63 Returns: internationalized string Type string &lt;static&gt; shuffleArray(array) Randomly sort an Array in place Fisher-Yates shuffle algorithm. Parameters: Name Type Description array Array Array to sort Source: utils.js, line 113 Ã— Search results Close "},"Photo.html":{"id":"Photo.html","title":"Class: Photo","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Class: Photo Photo new Photo(name, source) A photo for the screen saver Parameters: Name Type Description name string unique name source Object source item Source: photo.js, line 17 Methods &lt;private, static&gt; _isBadAspect(asp, screenAsp) â†’ {boolean} Determine if a photo would look bad zoomed or stretched on the screen Parameters: Name Type Description asp number aspect ratio of photo screenAsp number the screen aspect ratio Source: photo.js, line 66 Returns: true if a photo aspect ratio differs substantially from the screens' Type boolean &lt;static&gt; ignore(asp, screenAsp, photoSizing) â†’ {boolean} Determine if a photo should not be displayed Parameters: Name Type Description asp number aspect ratio screenAsp number the screen aspect ratio photoSizing int the sizing type Source: photo.js, line 79 Returns: true if the photo should not be displayed Type boolean &lt;static&gt; showSource(item) Create a new tab with a link to the original source of the current photo, if possible Parameters: Name Type Description item Object a photo item Source: photo.js, line 98 buildLabel(force) â†’ {string} Create the photo label Parameters: Name Type Description force boolean require display of label if true Source: photo.js, line 34 Returns: label describing the photo source and photographer name Type string Ã— Search results Close "},"PhotoSource.html":{"id":"PhotoSource.html","title":"Class: PhotoSource","body":" Documentation Namespaces app.Alarmapp.Backgroundapp.ChromeCastapp.Dataapp.Flickrapp.GooglePhotosapp.Httpapp.Optionsapp.PhotoViewapp.Redditapp.ScreenSaverapp.SSControlapp.Storageapp.Use500pxapp.Utils Classes PhotoPhotoSource Global Global Class: PhotoSource PhotoSource new PhotoSource(useName, photosName, type, isDaily, isArray, loadObj, loadFn, loadArgs) A potential source of photos for the screen saver Parameters: Name Type Description useName string The key for the boolean value that indicates if the source is selected photosName string The key for the collection of photos type string A descriptor of the photo source isDaily boolean Should the source be updated daily isArray boolean Is the source an Array of photo Arrays loadObj string the function wrapper for a photo source as a string loadFn string function to call to retrieve the photo collection as a string loadArgs Array Arguments to the loadFn Source: photo_sources.js, line 26 Members &lt;static&gt; SOURCES :Array Array of PhotoSources Type: Array Source: photo_sources.js, line 140 Methods &lt;static&gt; contains(useName) â†’ {boolean} Determine if a given string is a photo source Parameters: Name Type Description useName string String to check Source: photo_sources.js, line 193 Returns: true if photo source Type boolean &lt;static&gt; getSelectedPhotos() â†’ {Array} Get all the photos from all selected sources. These will be used by the screensaver. Source: photo_sources.js, line 180 Returns: Array of photos to display in screen saver Type Array &lt;static&gt; getUseNames() â†’ {Array} Get all the keys of useage boolean variables Source: photo_sources.js, line 167 Returns: Array of keys of useage boolean variables Type Array &lt;static&gt; process(useName) â†’ {Promise.&lt;void&gt;} Process the given photo source and save to localStorage. This normally requires a https call and may fail for various reasons Parameters: Name Type Description useName string The photo source to retrieve Source: photo_sources.js, line 209 Returns: void Type Promise.&lt;void&gt; &lt;static&gt; processAll() Process all the selected photo sources and save to localStorage. This normally requires a https call and may fail for various reasons Source: photo_sources.js, line 224 &lt;static&gt; processDaily() Process all the selected photo sources that are to be updated every day and save to localStorage. This normally requires a https call and may fail for various reasons Source: photo_sources.js, line 236 &lt;private&gt; _addType(arr) Add the type specifier (source of the photo) for each photo object in the array Parameters: Name Type Description arr Array an array of photo objects Source: photo_sources.js, line 99 &lt;private&gt; _getPhotos() â†’ {Array} Get all the photos from local storage Source: photo_sources.js, line 110 Returns: The Array of photos Type Array &lt;private&gt; _savePhotos(photos) â†’ {string} Save the photos to localStorage in a safe manner Parameters: Name Type Description photos Array an array of photo objects Source: photo_sources.js, line 81 Returns: non-null on error Type string process() â†’ {Promise.&lt;void&gt;} Process the photo source. This normally requires a https call and may fail for various reasons Save to localStorage if there is enough room. Source: photo_sources.js, line 53 Returns: void Type Promise.&lt;void&gt; use() â†’ {boolean} Determine if this source has been selected for display Source: photo_sources.js, line 42 Returns: true if selected Type boolean Ã— Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
